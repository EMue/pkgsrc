$NetBSD: patch-aa,v 1.4 1999/06/04 21:59:01 tron Exp $

--- x11.c.orig	Fri Jun  4 23:55:15 1999
+++ x11.c	Fri Jun  4 23:55:18 1999
@@ -59,8 +59,10 @@
 #define COLOR_8  (2)
 #define MONO_16  (3)
 #define COLOR_16 (4)
-#define MONO_32  (5)
-#define COLOR_32 (6)
+#define MONO_24  (5)
+#define COLOR_24 (6)
+#define MONO_32  (7)
+#define COLOR_32 (8)
 
 #define LABEL_LEFT_FLUSH (1<<0)
 #define LABEL_TOP_FLUSH  (1<<1)
@@ -76,6 +78,7 @@
 static void         pack_mono_1 _P((u16or32 *, u_char *));
 static void         pack_8 _P((u16or32 *, Pixel *, u_char *));
 static void         pack_16 _P((u16or32 *, Pixel *, u_char *));
+static void         pack_24 _P((u16or32 *, Pixel *, u_char *));
 static void         pack_32 _P((u16or32 *, Pixel *, u_char *));
 static void         x11_row _P((u_char *));
 static void         x11_cleanup _P((void));
@@ -376,6 +379,7 @@
   case MONO_1:
   case MONO_8:
   case MONO_16:
+  case MONO_24:
   case MONO_32:
     mono_dither_setup();
     pels = (Pixel *) malloc((unsigned) sizeof(Pixel) * 2);
@@ -386,6 +390,7 @@
 
   case COLOR_8:
   case COLOR_16:
+  case COLOR_24:
   case COLOR_32:
     if (XAllocNamedColor(dsply, cmap, "red", &xc, &junk) != 0)
       hlight = xc.pixel;
@@ -689,6 +694,14 @@
     bits_per_pixel = 16;
     break;
 
+    /* added this. -wsr */
+  case MONO_24:
+  case COLOR_24:
+    dith_size      = wdth;
+    xbuf_size      = dith_size * 3;
+    bits_per_pixel = 24;
+    break;
+
   case MONO_32:
   case COLOR_32:
     dith_size      = wdth;
@@ -715,16 +728,29 @@
                      xbuf_size);
 
   if (xim->bits_per_pixel != bits_per_pixel)
-  {
-    fflush(stdout);
-    fprintf(stderr,
-            "xearth %s: fatal - unexpected bits/pixel for depth %d\n",
-            VersionString, dpth);
-    fprintf(stderr,
-            "  (expected %d bits/pixel, actual value is %d)\n",
-            bits_per_pixel, xim->bits_per_pixel);
-    exit(1);
-  }
+    if ((xim->bits_per_pixel == 24) && (bits_per_pixel == 32))
+    {
+      x_type = mono ? MONO_24 : COLOR_24;
+
+      xbuf_size      = dith_size * 3;
+      bits_per_pixel = 24;
+
+      XDestroyImage(xim);
+      xim = XCreateImage(dsply, visl, (unsigned) dpth, ZPixmap, 0,
+                         (char *) xbuf, (unsigned) wdth, 1, 8,
+                         xbuf_size);
+    }
+    else
+    {
+      fflush(stdout);
+      fprintf(stderr,
+              "xearth %s: fatal - unexpected bits/pixel for depth %d\n",
+              VersionString, dpth);
+      fprintf(stderr,
+              "  (expected %d bits/pixel, actual value is %d)\n",
+              bits_per_pixel, xim->bits_per_pixel);
+      exit(1);
+    }
 
   if (x_type == MONO_1)
   {
@@ -817,6 +843,43 @@
 }
 
 
+/* pack pixels into ximage format (assuming bits_per_pixel == 24)
+ */
+static void pack_24(src, map, dst)
+     u16or32 *src;
+     Pixel   *map;
+     u_char  *dst;
+{
+  int      i, i_lim;
+  unsigned val;
+
+  i_lim = wdth;
+
+  if (xim->byte_order == MSBFirst)
+  {
+    for (i=0; i<i_lim; i++)
+    {
+      val    = map[src[i]];
+      dst[0] = (val >> 16) & 0xff;
+      dst[1] = (val >> 8) & 0xff;
+      dst[2] = val & 0xff;
+      dst   += 3;
+    }
+  }
+  else /* (xim->byte_order == LSBFirst) */
+  {
+    for (i=0; i<i_lim; i++)
+    {
+      val    = map[src[i]];
+      dst[0] = val & 0xff;
+      dst[1] = (val >> 8) & 0xff;
+      dst[2] = (val >> 16) & 0xff;
+      dst   += 3;
+    }
+  }
+}
+
+
 /* pack pixels into ximage format (assuming bits_per_pixel == 32)
  */
 static void pack_32(src, map, dst)
@@ -876,6 +939,11 @@
     pack_16(dith, pels, xbuf);
     break;
 
+  case MONO_24:
+    mono_dither_row(row, dith);
+    pack_24(dith, pels, xbuf);
+    break;
+
   case MONO_32:
     mono_dither_row(row, dith);
     pack_32(dith, pels, xbuf);
@@ -889,6 +957,11 @@
   case COLOR_16:
     dither_row(row, dith);
     pack_16(dith, pels, xbuf);
+    break;
+
+  case COLOR_24:
+    dither_row(row, dith);
+    pack_24(dith, pels, xbuf);
     break;
 
   case COLOR_32:
