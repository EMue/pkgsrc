$NetBSD: patch-ao,v 1.2 1999/08/22 22:55:46 kim Exp $

--- expire.c.orig	Wed Aug 14 23:16:10 1996
+++ expire.c	Sun Aug 22 18:05:19 1999
@@ -95,7 +95,7 @@
 register group_header *gh;
 {
     FILE *old, *data, *ix;
-    off_t old_max_offset;
+    long old_max_offset;
     register article_number *list;
     article_number old_last_article;
     long count;
@@ -148,9 +148,9 @@
     old_last_article = gh->last_db_article;
     gh->last_db_article = 0;
 
-    gh->index_write_offset = (off_t)0;
+    gh->index_write_offset = (long)0;
     old_max_offset = gh->data_write_offset;
-    gh->data_write_offset = (off_t)0;
+    gh->data_write_offset = (long)0;
 
     gh->master_flag &= ~M_EXPIRE;
     gh->master_flag |= M_BLOCKED;
@@ -268,7 +268,7 @@
 {
     FILE *old_x, *old_d;
     FILE *new;
-    off_t index_offset, data_offset, new_offset;
+    long index_offset, data_offset, new_offset;
     long count, expire_count;
     char *err_message;
 
@@ -333,7 +333,7 @@
      *	calculate the number of entries to copy
      */
 
-    count = gh->index_write_offset / sizeof(off_t);
+    count = gh->index_write_offset / sizeof(long);
 
     /*
      *	data offset is the offset into the old data file for the
@@ -342,7 +342,7 @@
      *	offset 'index_offset'.
      */
 
-    data_offset = (off_t)0;
+    data_offset = (long)0;
 
     /*
      *	read 'count' entries from the old index file starting from
@@ -356,7 +356,7 @@
 	if (!db_read_offset(old_x, &new_offset))
 	    expire_error("INDEX: too short");
 
-	if (data_offset == (off_t)0) data_offset = new_offset;
+	if (data_offset == (long)0) data_offset = new_offset;
 
 	new_offset -= data_offset;
 	if (!db_write_offset(new, &new_offset))
