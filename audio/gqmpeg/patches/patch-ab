$NetBSD: patch-ab,v 1.6 1999/06/15 02:06:39 hubertf Exp $

From rxg@ms25.url.com.tw Tue Jun 15 02:49:50 1999
Date: Mon, 14 Jun 1999 13:58:57 +0100
From: Rui-Xiang Guo <rxg@ms25.url.com.tw>
To: Hubert Feyrer <hubert.feyrer@rz.uni-regensburg.de>
Subject: Re: pkg/7768: new patches for 'gqmpeg'

I send you the patch for saving your time. :)
Should we need to remove some unnecesarry mixer control(eg. mic)?
This patch has a small bug. When you choose the mixer control 'master',
the balance control is unusable. The rest controls are OK.
We can fix this but I never use balance control except testing this
patch. :>
Can you tell me what you think? 
Thanks!
    [ Part 2: "Attached Text" ]

$NetBSD: patch-ab,v 1.6 1999/06/15 02:06:39 hubertf Exp $

--- mixer.c.orig	Wed Jun  2 05:50:45 1999
+++ mixer.c	Mon Jun 14 14:14:29 1999
@@ -24,7 +24,7 @@
 #include <linux/soundcard.h>
 #endif
 
-#if defined(sun) && defined(__svr4__)
+#if defined(sun) && defined(__svr4__) || defined(__NetBSD__)
 #include <sys/audioio.h>
 #endif
 
@@ -32,11 +32,6 @@
 #include <machine/soundcard.h>
 #endif
 
-#ifdef __NetBSD__
-#include <soundcard.h>
-#undef _POSIX_SOURCE
-#endif
-
 #ifdef __sgi
 #include <math.h>
 #include <audio.h>
@@ -65,7 +60,7 @@
 static GList *device_list = NULL;
 static DeviceData *current_device = NULL;
 
-#if defined (linux) || defined (__FreeBSD__) || defined (__NetBSD__)
+#if defined (linux) || defined (__FreeBSD__)
 void mixer_init(gint init_device_id)
 {
 	char *device_names[] = SOUND_DEVICE_NAMES;
@@ -100,11 +95,7 @@
 	/* get device listing */
 	for (i=0; i<SOUND_MIXER_NRDEVICES; i++)
 		{
-		if ((dev_mask & (1<<i)) /* skip unsupported */
-#ifndef __NetBSD__
-		   && !(rec_mask & (1<<i)) /* & record devs */
-#endif
-		   )
+		if ((dev_mask & (1<<i)) && !(rec_mask & (1<<i))) /* skip unsupported & record devs */
  			{
 			DeviceData *device = g_new0(DeviceData, 1);
 			device->device_id = i;
@@ -186,6 +177,199 @@
 	return vol;
 }
 
+#elif defined(__NetBSD__)
+mixer_devinfo_t *infos;
+mixer_ctrl_t *values;
+void mixer_init(gint init_device_id)
+{
+  int fd, i, ndev;
+  char *mixer_device;
+  audio_device_t adev;
+  mixer_devinfo_t dinfo;
+
+  mixer_device = getenv("MIXERDEVICE");
+  if (mixer_device == NULL)
+    mixer_device = "/dev/mixer";
+
+  if ((fd = open(mixer_device, O_RDWR)) == -1) {
+    perror(mixer_device);
+    mixer_enabled = FALSE;
+  }
+
+  if (ioctl(fd, AUDIO_GETDEV, &adev) == -1) {
+    perror(mixer_device);
+    close(fd);
+    mixer_enabled = FALSE;
+  }
+
+  for (ndev = 0; ; ndev++) {
+    dinfo.index = ndev;
+    if (ioctl(fd, AUDIO_MIXER_DEVINFO, &dinfo) == -1)
+      break;
+  }
+  infos = calloc(ndev, sizeof *infos);
+  values = calloc(ndev, sizeof *values);
+
+  for (i = 0; i < ndev; i++) {
+    infos[i].index = i;
+    ioctl(fd, AUDIO_MIXER_DEVINFO, &infos[i]);
+  }
+
+  for (i = 0; i < ndev; i++) {
+    values[i].dev = i;
+    values[i].type = infos[i].type;
+    if (infos[i].type != AUDIO_MIXER_CLASS) {
+      values[i].un.value.num_channels = 2;
+      if (ioctl(fd, AUDIO_MIXER_READ, &values[i]) == -1) {
+        values[i].un.value.num_channels = 1;
+        if (ioctl(fd, AUDIO_MIXER_READ, &values[i]) == -1)
+          perror("AUDIO_MIXER_READ");
+      }
+    }
+  }
+  close(fd);
+
+  for (i = 0; i < ndev; i++) {
+    if (infos[i].type == AUDIO_MIXER_VALUE) {
+      DeviceData *device = g_new0(DeviceData, 1);
+      device->device_id = i;
+      device->device_name = infos[i].label.name;
+      device->stereo = 1;
+      device_list = g_list_append(device_list, device);
+
+      if (debug_mode) printf("Mixer device added to list: %d, %s, %d\n",
+                             device->device_id, device->device_name,
+                             device->stereo);
+      if (init_device_id == i) current_device = device;
+    }
+  }
+
+  if (device_list) {
+    mixer_enabled = TRUE;
+    if (!current_device)
+      current_device = device_list->data;
+    current_vol = mixer_get_vol(current_device);
+  } else {
+    mixer_enabled = FALSE;
+  }
+}
+
+static void mixer_set_vol(DeviceData *device, gint vol)
+{
+  int fd;
+  char *audioctl_device;
+  char *mixer_device;
+  audio_device_t adev;
+  audio_info_t ainfo;
+  mixer_ctrl_t *m;
+
+  audioctl_device = getenv("AUDIOCTLDEVICE");
+  if (audioctl_device == NULL)
+    audioctl_device = "/dev/audioctl";
+
+  if ((fd = open(audioctl_device, O_RDONLY)) == -1) {
+    perror(audioctl_device);
+    mixer_enabled = FALSE;
+  }
+
+  if (ioctl(fd, AUDIO_GETDEV, &adev) == -1) {
+    perror(audioctl_device);
+    close(fd);
+    mixer_enabled = FALSE;
+  }
+
+  AUDIO_INITINFO(&ainfo);
+  /* from AUDIO_LEFT_BALANCE (0) to AUDIO_RIGHT_BALANCE (64) */
+  ainfo.play.balance = current_bal * AUDIO_RIGHT_BALANCE / 100;
+
+  if (ioctl(fd, AUDIO_SETINFO, &ainfo) == -1) {
+    perror("AUDIO_SETINFO");
+    close(fd);
+  }
+  close(fd);
+
+  mixer_device = getenv("MIXERDEVICE");
+  if (mixer_device == NULL)
+    mixer_device = "/dev/mixer";
+
+  if ((fd = open(mixer_device, O_RDWR)) == -1) {
+    perror(mixer_device);
+    close(fd);
+  }
+
+  m = &values[device->device_id];
+  if (ioctl(fd, AUDIO_MIXER_WRITE, m) == -1) {
+    perror("AUDIO_MIXER_WRITE");
+    close(fd);
+  }
+  /* from AUDIO_MIN_GAIN (0) to AUDIO_MAX_GAIN (255) */
+  m->un.value.level[0] = m->un.value.level[1] = vol * AUDIO_MAX_GAIN / 100;
+
+  if (debug_mode) printf("volume set to %d (%d)\n", vol, current_bal);
+
+  close(fd);
+}
+
+static gint mixer_get_vol(DeviceData *device)
+{
+  int fd;
+  char *audioctl_device;
+  char *mixer_device;
+  audio_device_t adev;
+  audio_info_t ainfo;
+  mixer_ctrl_t *m;
+
+  audioctl_device = getenv("AUDIOCTLDEVICE");
+  if (audioctl_device == NULL)
+    audioctl_device = "/dev/audioctl";
+
+  if ((fd = open(audioctl_device, O_RDONLY)) == -1) {
+    perror(audioctl_device);
+    mixer_enabled = FALSE;
+    return -1;
+  }
+
+  if (ioctl(fd, AUDIO_GETDEV, &adev) == -1) {
+    perror(audioctl_device);
+    close(fd);
+    mixer_enabled = FALSE;
+    return -1;
+  }
+
+  if (ioctl(fd, AUDIO_GETINFO, &ainfo) == -1) {
+    perror("AUDIO_GETINFO");
+    close(fd);
+    return -1;
+  }
+
+  if (ainfo.play.balance > AUDIO_RIGHT_BALANCE)
+    current_bal = 50;
+  else
+    current_bal = ainfo.play.balance * 100 / AUDIO_RIGHT_BALANCE;
+
+  close(fd);
+
+  mixer_device = getenv("MIXERDEVICE");
+  if (mixer_device == NULL)
+    mixer_device = "/dev/mixer";
+
+  if ((fd = open(mixer_device, O_RDWR)) == -1) {
+    perror(mixer_device);
+    close(fd);
+    return -1;
+  }
+
+  m = &values[device->device_id];
+  if (ioctl(fd, AUDIO_MIXER_READ, m) == -1) {
+    perror("AUDIO_MIXER_READ");
+    close(fd);
+    return -1;
+  }
+  close(fd);
+
+  return m->un.value.level[0] * 100 / AUDIO_MAX_GAIN;
+}
+
 #elif defined(sun) && defined(__svr4__)
 static int device_ids[] = { AUDIO_SPEAKER,
 			    AUDIO_LINE_OUT,
@@ -444,7 +628,7 @@
 
 #endif
 
-#if defined(sun) && defined(__svr4__)
+#if defined(sun) && defined(__svr4__) || defined(__NetBSD__)
 /* from 0 through 100% */
 void set_volume(gint vol)
 {
