$NetBSD: patch-ad,v 1.3 1999/06/07 08:19:48 frueauf Exp $

--- console/audio/linux/audiodrv.cpp.orig	Sun Mar  7 08:38:58 1999
+++ console/audio/linux/audiodrv.cpp	Wed Jun  2 20:06:29 1999
@@ -1,8 +1,5 @@
-//
-// 1997/09/27 21:38:01
-//
 // --------------------------------------------------------------------------
-// ``Open Sound System (OSS)'' / Linux specific audio interface.
+// ``Open Sound System (OSS)'' specific audio driver interface.
 // --------------------------------------------------------------------------
 
 #include "audiodrv.h"
@@ -21,6 +18,7 @@
 	channels = 0;
 	encoding = 0;
 	precision = 0;
+    swapEndian = false;
 	audioHd = (-1);
 }
 
@@ -35,7 +33,8 @@
 {
 	if ((audioHd=open(AUDIODEVICE,O_WRONLY,0)) == (-1))
     {
-		errorString = "AUDIO: Could not open audio device.";
+        perror(AUDIODEVICE);
+		errorString = "ERROR: Could not open audio device.";
 		return false;
     }
 	
@@ -47,34 +46,102 @@
 	fragments = inFragments;
 	fragSizeBase = inFragBase;
 
-	// Set sample precision and type of encoding.
-	int dsp_sampleSize;
-	if (precision == SIDEMU_16BIT)
-		dsp_sampleSize = 16;
-	else  // if (precision == SIDEMU_8BIT)
-		dsp_sampleSize = 8;
-	if (ioctl(audioHd,SNDCTL_DSP_SAMPLESIZE,&dsp_sampleSize) == (-1))
+    int mask;
+    // Query supported sample formats.
+    if (ioctl(audioHd,SNDCTL_DSP_GETFMTS,&mask) == (-1))
     {
-		errorString = "AUDIO: Could not set sample size.";
+        perror(AUDIODEVICE);
+		errorString = "AUDIO: Could not get sample formats.";
 		return false;
     }
-	// Verify and accept the sample precision the driver accepted.
-	if (dsp_sampleSize == 16)
+
+    // Assume CPU and soundcard have same endianess.
+    swapEndian = false;
+    
+    int wantedFormat;
+	// Set sample precision and type of encoding.
+	if (precision == SIDEMU_16BIT)
     {
-		precision = SIDEMU_16BIT;
-		encoding = SIDEMU_SIGNED_PCM;
+#if defined(WORDS_BIGENDIAN)
+        if (mask & AFMT_S16_BE)
+        {
+            wantedFormat = AFMT_S16_BE;
+            encoding = SIDEMU_SIGNED_PCM;
+        }
+        else if (mask & AFMT_U16_BE)
+        {
+            wantedFormat = AFMT_U16_BE;
+            encoding = SIDEMU_UNSIGNED_PCM;
+        }
+        else if (mask & AFMT_S16_LE)
+        {
+            wantedFormat = AFMT_S16_LE;
+            encoding = SIDEMU_SIGNED_PCM;
+            swapEndian = true;
+        }
+        else if (mask & AFMT_U16_LE)
+        {
+            wantedFormat = AFMT_U16_LE;
+            encoding = SIDEMU_UNSIGNED_PCM;
+            swapEndian = true;
+        }
+#else
+        if (mask & AFMT_S16_LE)
+        {
+            wantedFormat = AFMT_S16_LE;
+            encoding = SIDEMU_SIGNED_PCM;
+        }
+        else if (mask & AFMT_U16_LE)
+        {
+            wantedFormat = AFMT_U16_LE;
+            encoding = SIDEMU_UNSIGNED_PCM;
+        }
+        else if (mask & AFMT_S16_BE)
+        {
+            wantedFormat = AFMT_S16_BE;
+            encoding = SIDEMU_SIGNED_PCM;
+            swapEndian = true;
+        }
+        else if (mask & AFMT_U16_BE)
+        {
+            wantedFormat = AFMT_U16_BE;
+            encoding = SIDEMU_UNSIGNED_PCM;
+            swapEndian = true;
+        }
+#endif
+        else  // 16-bit not supported
+        {
+            wantedFormat = AFMT_U8;
+            precision = SIDEMU_8BIT;
+            encoding = SIDEMU_UNSIGNED_PCM;
+        }
     }
-	else if (dsp_sampleSize == 8)
+	else  // if (precision == SIDEMU_8BIT)
     {
+		wantedFormat = AFMT_U8;
 		precision = SIDEMU_8BIT;
 		encoding = SIDEMU_UNSIGNED_PCM;
     }
-	else
-	{
-		errorString = "AUDIO: Could not set sample size.";
-		return false;
-	}
 
+    if ( !(mask&wantedFormat) )
+    {
+        errorString = "AUDIO: Desired sample encoding not supported.";
+        return false;
+    }
+    
+    int format = wantedFormat;
+    if (ioctl(audioHd,SNDCTL_DSP_SETFMT,&format) == (-1))
+    {
+        perror(AUDIODEVICE);
+		errorString = "AUDIO: Could not set sample format.";
+		return false;
+    }
+    if (format != wantedFormat)  
+    {
+		errorString = "AUDIO: Audio driver did not accept sample format.";
+		return false;
+    }
+    
 	// Set mono/stereo.
 	int dsp_stereo;
 	if (channels == SIDEMU_STEREO)
@@ -83,6 +150,7 @@
 		dsp_stereo = 0;
 	if (ioctl(audioHd,SNDCTL_DSP_STEREO,&dsp_stereo) == (-1))
     {
+        perror(AUDIODEVICE);
 		errorString = "AUDIO: Could not set mono/stereo.";
 		return false;
     }
@@ -101,6 +169,7 @@
 	int dsp_speed = frequency;
 	if (ioctl(audioHd,SNDCTL_DSP_SPEED,&dsp_speed) == (-1))
     {
+        perror(AUDIODEVICE);
 		errorString = "AUDIO: Could not set frequency.";
 		return false;
     }
@@ -120,6 +189,7 @@
 	audio_buf_info myAudInfo;
 	if (ioctl(audioHd,SNDCTL_DSP_GETOSPACE,&myAudInfo) == (-1))
 	{
+        perror(AUDIODEVICE);
 		errorString = "AUDIO: Could not get audio_buf_info.";
 		return false;
 	}
@@ -145,6 +215,15 @@
 {
 	if (audioHd != (-1))
 	{
-		write(audioHd,pBuffer,bufferSize);
+        if (swapEndian)
+        {
+            for (int n=0; n<bufferSize; n+=2)
+            {
+                ubyte tmp = pBuffer[n+0];
+                pBuffer[n+0] = pBuffer[n+1];
+                pBuffer[n+1] = tmp;
+            }
+        }
+        write(audioHd,pBuffer,bufferSize);
 	}
 }
