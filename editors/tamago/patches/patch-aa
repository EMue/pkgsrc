$NetBSD: patch-aa,v 1.1 2001/02/08 03:24:12 jun Exp $

diff -u -3 ../tamago-4.0.6/ChangeLog ./ChangeLog
--- ../tamago-4.0.6/ChangeLog	Mon Jan 17 09:48:50 2000
+++ ./ChangeLog
@@ -1,3 +1,129 @@
+2000-06-02  KATAYAMA Yoshio <kate@pfu.co.jp>
+
+	* egg/wnn.el (wnn): Fix docstring.
+	(wnn-backend-plist): Include egg-special-candidate.
+	(wnn-special-candidate): New function.
+	(wnn-pinyin-zhuyin-bunsetsu, wnn-pinyin-zhuyin-string): New
+	functions.
+	(egg-activate-wnn): Fix docstring.
+
+	* egg/sj3.el (sj3, egg-activate-sj3): Fix docstring.
+
+	* egg/canna.el (egg-activate-canna): Fix docstring.
+
+	* menudiag.el: Mostly rewritten.
+
+	* leim-list.el: Docstrings for autoload fixed.
+
+	* its.el (its): Fix docstring.
+	(its-mode-map): Fix bindings.
+	(its-fence-mode, egg-sub-mode-map-alist): New variables.
+	(its-enter/leave-fence): New function.
+	(its-put-cursor): Add text properties point-entered, point-left,
+	modification-hooks.
+	(its-in-fence-p): Check also read-only property.
+	(its-hiragana, its-katakana): Just call its-convert.
+	(its-hankaku, its-japanese-hankaku): These functions deleted.
+	(its-full-half-table, its-half-full-table): New variables.
+	Initialize them.
+	(its-half-width, its-full-width): New functions.
+	(its-convert): Args changed.
+
+	* its-keydef.el (its-make-select-func): Add check by
+	(egg-conversion-fence-p).
+
+	* egg.el (egg): Fix docstring.
+	(egg-current-keymap): This variable deleted.
+	(egg-mode-map-alist, egg-sub-mode-map-alist): New variables.
+	(define-egg-mode-map): New macro.
+	(modefull, modeless): New egg mode maps.
+	(egg-enter/leave-fence-hook): New variable.
+	(egg-enter/leave-fence): New function.
+	(egg-activated): New variable.
+	(egg-activate-keymap): New variable.
+	(egg-modify-fence, egg-post-command-func): New functions.
+	(egg-change-major-mode-buffer): New variable.
+	(egg-activate-keymap-after-command, egg-change-major-mode-func):
+	New functions.
+	(egg-mode): Initialize egg-modefull-mode, egg-modeless-mode.
+	(egg-modefull-map, egg-modeless-map): These functions deleted.
+	(egg-set-face): Preserve the current modification-hooks property.
+
+	* egg-com.el (ccl-decode-egg-binary): Fix BUFFER-MAGNIFICATION.
+	(ccl-encode-egg-binary): Likewise.
+
+	* egg-cnv.el (egg-conv): Fix docstring.
+	(egg-conversion-auto-candidate-menu): Fix docstring.
+	(egg-conversion-auto-candidate-menu-show-all): New variable.
+	(egg-conversion-sort-by-converted-string): New variable.
+	(egg-conversion-fence-p): New function.
+	(egg-define-backend-functions): Include egg-special-candidate.
+	(egg-conversion-map): Define up, down, etc.
+	(egg-conversion-mode): New variable.  Register it in
+	egg-sub-mode-map-alist.
+	(egg-conversion-enter/leave-fence): New function.  Register it in
+	egg-enter/leave-fence-hook.
+	(egg-exit-conversion-unread-char): Use single setq.
+	(egg-make-bunsetsu): Add text properties point-entered and
+	point-left.
+	(egg-set-menu-mode-in-use, egg-unset-menu-mode-in-use)
+	(egg-set-candsel-info): Args changed.
+	(egg-get-candsel-target-major): Code changed.
+	(egg-get-candsel-target-minor): Code changed.
+	(egg-insert-new-bunsetsu): Args changed.
+	(egg-candidate-select-counter): Make it buffer local.
+	(egg-next-candidate-internal): Args changed.
+	(egg-sort-item): New functions.
+	(egg-select-candidate-major): New arg SORT.
+	(egg-select-candidate-minor, egg-select-candidate-list-all-major)
+	(egg-select-candidate-list-all-minor)
+	(egg-select-candidate-internal): Likewise.
+	(egg-hiragana): New function.
+	(egg-katakana, egg-pinyin, egg-zhuyin, egg-hangul): Aliases of
+	egg-hiragana.
+	(egg-special-convert): New function.
+	(egg-enlarge-bunsetsu-internal): Code changed.
+	(egg-reconvert-bunsetsu-internal, egg-decide-before-point)
+	(egg-decide-first-char, egg-exit-conversion)
+	(egg-abort-conversion): Likewise.
+
+2000-02-01  Takanori Saneto  <sanewo@ba2.so-net.ne.jp>
+
+	* egg/sj3rpc.el (sj3rpc-tanbunsetsu-conversion): should use
+	  let* instead of let.
+
+2000-01-20  Katsumi Yamaoka <yamaoka@jpl.org>
+
+	* egg/sj3.el (sj3-word-registration): New function.
+	(sj3-hinshi-select): New function.
+	(sj3-dictionary-select): New function.
+	(sj3-conversion-backend): Add `sj3-word-registration'.
+	(sj3-hinshi-name): New function.
+	(sj3-hinshi-menu): New variable.
+	(sj3-register-2, sj3-register-1): Add messages.
+	(sj3-server-coding-system-list): Remove.
+	(sj3-server-version): Move to egg/sj3rpc.el.
+	(sj3-server-port, sj3-hostname): Strip "*" from the doc string.
+
+	* egg/sj3rpc.el (sj3rpc-add-word): New function.
+	(sj3rpc-kugiri-stdy, sj3rpc-get-bunsetsu-candidates): Use
+	`sj3-server-coding-system' insted of `sj3rpc-server-coding-system'.
+	(sj3rpc-tanbunsetsu-conversion, sj3rpc-get-bunsetsu-candidates-sub,
+	sj3rpc-begin): Use `sj3-server-coding-system' insted of
+	`sj3rpc-server-coding-system'; don't specify an argument of
+	`sj3rpc-unpack-mb-string'.
+	(sj3rpc-unpack-mb-string): Don't allow the argument; use
+	`sj3rpc-server-coding-system'.
+	(sj3rpc-server-coding-system): Remove macro.
+	(sj3-const): Switch on the return value of `sj3-sjis-p' instead of
+	`sj3-server-version'.
+	(sj3-sjis-p): New macro.
+	(sj3-server-coding-system): New variable; default to `shift_jis'.
+	(sj3-server-version): Move from egg/sj3.el; use `defvar' insted of
+	`defcustom'.
+
+	* eggrc: Remove SJ3 stuff.
+
 2000-01-17  TOMURA Satoru <tomura@etl.go.jp>
 
 	* Version 4.0.6 released
diff -u -3 ../tamago-4.0.6/Makefile.in ./Makefile.in
--- ../tamago-4.0.6/Makefile.in	Sun Jan 16 00:39:09 2000
+++ ./Makefile.in
@@ -138,8 +139,8 @@
 egg/sj3rpc.elc: egg-com.elc egg/sj3.elc
 egg/wnnrpc.elc: egg-com.elc egg/wnn.elc
 
-egg.elc its/ascii.elc its/erpin.elc its/hankata.elc \
-its/hira.elc its/jeonkak.elc its/pinyin.elc \
+egg.elc its/ascii.elc its/aynu.elc its/erpin.elc \
+its/hankata.elc its/hira.elc its/jeonkak.elc its/pinyin.elc \
 its/hangul.elc its/kata.elc its/quanjiao.elc \
 its/zenkaku.elc its/zhuyin.elc: its-keydef.elc
 
Common subdirectories: ../tamago-4.0.6/doc and ./doc
Common subdirectories: ../tamago-4.0.6/egg and ./egg
diff -u -3 ../tamago-4.0.6/egg-cnv.el ./egg-cnv.el
--- ../tamago-4.0.6/egg-cnv.el	Tue Jan 11 20:59:10 2000
+++ ./egg-cnv.el
@@ -34,19 +34,29 @@
 (require 'egg-edep)
 
 (defgroup egg-conv nil
-  "Conversion backend Interface of Tamagotchy"
+  "Conversion Backend Interface of Tamago 4."
   :group 'egg)
 
-(defcustom egg-conversion-wrap-select nil
+(defcustom egg-conversion-wrap-select t
   "*Candidate selection wraps around to first candidate, if non-NIL.
 Otherwise stop at the last candidate."
   :group 'egg-conv :type 'boolean)
 
 (defcustom egg-conversion-auto-candidate-menu 0
-  "*Automatically enter the candidate selectionmenu mode at N times
+  "*Automatically enter the candidate selection mode at N times
 next/previous-candidate, if positive number N."
   :group 'egg-conv :type 'integer)
 
+(defcustom egg-conversion-auto-candidate-menu-show-all nil
+  "*Enter show all candiate mode when automatic candidate selection
+mode, if non-NIL."
+  :group 'egg-conv :type 'boolean)
+
+(defcustom egg-conversion-sort-by-converted-string nil
+  "*Sort candidate list by converted string on candidate selection
+mode, if non-NIL."
+  :group 'egg-conv :type 'boolean)
+
 (defcustom egg-conversion-fence-invisible nil
   "*Make fence marks invisible, if non-NIL."
   :group 'egg-conv :type 'boolean)
@@ -207,6 +217,10 @@
 (defsubst egg-bunsetsu-set-info (bunsetsu info)
   (setcdr bunsetsu info))
 
+(defun egg-conversion-fence-p ()
+  (and (egg-get-backend (point))
+       (get-text-property (point) 'read-only)))
+
 (defvar egg-finalize-backend-list nil)
 
 (defun egg-set-finalize-backend (func-list)
@@ -243,6 +257,7 @@
   (egg-major-bunsetsu-continue-p (bunsetsu))
   (egg-list-candidates (bunsetsu-list prev-b next-b major))
   (egg-decide-candidate (bunsetsu-list candidate-pos prev-b next-b))
+  (egg-special-candidate (bunsetsu-list prev-b next-b major type))
   (egg-change-bunsetsu-length (bunsetsu-list prev-b next-b length major))
   (egg-bunsetsu-combinable-p (bunsetsu next-b)) 
   (egg-end-conversion (bunsetsu-list abort))
@@ -263,7 +278,7 @@
 (defun egg-start-conversion-noconv (backend yomi-string context)
   (let ((string (copy-sequence yomi-string))
 	(language (egg-get-language 0 yomi-string)))
-    (set-text-properties 0 (length string) nil string)
+    (egg-remove-all-text-properties 0 (length string) string)
     (list (egg-bunsetsu-create backend (vector string language)))))
 
 (defun egg-get-bunsetsu-source-noconv (bunsetsu)
@@ -429,7 +444,8 @@
 	  (setq last-chinese lang))
       (setq j i
 	    i (egg-next-single-property-change i 'egg-lang str len))
-      (set-text-properties j i (list 'egg-lang lang) str))))
+      (egg-remove-all-text-properties j i str)
+      (put-text-property j i 'egg-lang lang str))))
 
 ;;; Should think again the interface to language-info-alist
 (defun egg-charset-to-language (charset)
@@ -478,7 +494,8 @@
 	    s (substring source i j)
 	    lang (egg-get-language 0 s)
 	    backend (egg-get-conversion-backend lang n t))
-      (set-text-properties 0 (- j i) (list 'egg-lang lang) s)
+      (egg-remove-all-text-properties 0 (- j i) s)
+      (put-text-property 0 (- j i) 'egg-lang lang s)
       (setq retval (nconc retval (list (list backend (list lang) s)))
 	    i j))
     (prog1
@@ -536,53 +553,72 @@
     (while (< i 127)
       (define-key map (vector i) 'egg-exit-conversion-unread-char)
       (setq i (1+ i)))
-    (define-key map "\C-@"   'egg-decide-first-char)
-    (define-key map [?\C-\ ] 'egg-decide-first-char)
-    (define-key map "\C-a"   'egg-beginning-of-conversion-buffer)
-    (define-key map "\C-b"   'egg-backward-bunsetsu)
-    (define-key map "\C-c"   'egg-abort-conversion)
-    (define-key map "\C-e"   'egg-end-of-conversion-buffer)
-    (define-key map "\C-f"   'egg-forward-bunsetsu)
-    (define-key map "\C-h"   'egg-help-command)
-    (define-key map "\C-i"   'egg-shrink-bunsetsu-major)
-    (define-key map "\C-k"   'egg-decide-before-point)
-;;    (define-key map "\C-l"   'egg-exit-conversion)  ; Don't override C-L
-    (define-key map "\C-m"   'egg-exit-conversion)
-    (define-key map "\C-n"   'egg-next-candidate-major)
-    (define-key map "\C-o"   'egg-enlarge-bunsetsu-major)
-    (define-key map "\C-p"   'egg-previous-candidate-major)
-    (define-key map "\C-r"   'egg-reconvert-bunsetsu)
-    (define-key map "\C-t"   'egg-toroku-bunsetsu)
-    (define-key map "\C-v"   'egg-inspect-bunsetsu)
-    (define-key map "\M-i"   'egg-shrink-bunsetsu-minor)
-    (define-key map "\M-n"   'egg-next-candidate-minor)
-    (define-key map "\M-o"   'egg-enlarge-bunsetsu-minor)
-    (define-key map "\M-p"   'egg-previous-candidate-minor)
-    (define-key map "\M-r"   'egg-reconvert-bunsetsu-from-source)
-    (define-key map "\M-s"   'egg-select-candidate-major)
-    (define-key map "\M-v"   'egg-toggle-inspect-mode)
-    (define-key map "\M-z"   'egg-select-candidate-minor)
-    (define-key map "\e\C-s" 'egg-select-candidate-list-all-major)
-    (define-key map "\e\C-z" 'egg-select-candidate-list-all-minor)
-    (define-key map [return] 'egg-exit-conversion)
-    (define-key map [right]  'egg-forward-bunsetsu)
-    (define-key map [left]   'egg-backward-bunsetsu)
-    (define-key map " "      'egg-next-candidate)
-    (define-key map "/"      'egg-exit-conversion)
-    ;;;(define-key map "\M-h"   'egg-hiragana)
-    ;;;(define-key map "\M-k"   'egg-katakana)
-    ;;;(define-key map "\M-<"   'egg-hankaku)
-    ;;;(define-key map "\M->"   'egg-zenkaku)
+    (define-key map "\C-@"      'egg-decide-first-char)
+    (define-key map [?\C-\ ]    'egg-decide-first-char)
+    (define-key map "\C-a"      'egg-beginning-of-conversion-buffer)
+    (define-key map "\C-b"      'egg-backward-bunsetsu)
+    (define-key map "\C-c"      'egg-abort-conversion)
+    (define-key map "\C-e"      'egg-end-of-conversion-buffer)
+    (define-key map "\C-f"      'egg-forward-bunsetsu)
+    (define-key map "\C-h"      'egg-help-command)
+    (define-key map "\C-i"      'egg-shrink-bunsetsu-major)
+    (define-key map "\C-k"      'egg-decide-before-point)
+;;    (define-key map "\C-l"      'egg-exit-conversion)  ; Don't override C-L
+    (define-key map "\C-m"      'egg-exit-conversion)
+    (define-key map "\C-n"      'egg-next-candidate-major)
+    (define-key map "\C-o"      'egg-enlarge-bunsetsu-major)
+    (define-key map "\C-p"      'egg-previous-candidate-major)
+    (define-key map "\C-r"      'egg-reconvert-bunsetsu)
+    (define-key map "\C-t"      'egg-toroku-bunsetsu)
+    (define-key map "\C-v"      'egg-inspect-bunsetsu)
+    (define-key map "\M-i"      'egg-shrink-bunsetsu-minor)
+    (define-key map "\M-n"      'egg-next-candidate-minor)
+    (define-key map "\M-o"      'egg-enlarge-bunsetsu-minor)
+    (define-key map "\M-p"      'egg-previous-candidate-minor)
+    (define-key map "\M-r"      'egg-reconvert-bunsetsu-from-source)
+    (define-key map "\M-s"      'egg-select-candidate-major)
+    (define-key map "\M-v"      'egg-toggle-inspect-mode)
+    (define-key map "\M-z"      'egg-select-candidate-minor)
+    (define-key map "\e\C-s"    'egg-select-candidate-list-all-major)
+    (define-key map "\e\C-z"    'egg-select-candidate-list-all-minor)
+    (define-key map [return]    'egg-exit-conversion)
+    (define-key map [right]     'egg-forward-bunsetsu)
+    (define-key map [left]      'egg-backward-bunsetsu)
+    (define-key map [up]        'egg-previous-candidate)
+    (define-key map [down]      'egg-next-candidate)
+    (define-key map [backspace] 'egg-abort-conversion)
+    (define-key map [clear]     'egg-abort-conversion)
+    (define-key map [delete]    'egg-abort-conversion)
+    (define-key map " "         'egg-next-candidate)
+    (define-key map "/"         'egg-exit-conversion)
+    (define-key map "\M-h"      'egg-hiragana)
+    (define-key map "\M-k"      'egg-katakana)
+    (define-key map "\M-P"      'egg-pinyin)
+    (define-key map "\M-Z"      'egg-zhuyin)
+    (define-key map "\M-H"      'egg-hangul)
     map)
   "Keymap for EGG Conversion mode.")
-
 (fset 'egg-conversion-map egg-conversion-map)
 
+(defvar egg-conversion-mode nil)
+(make-variable-buffer-local 'egg-conversion-mode)
+(put 'egg-conversion-mode 'permanent-local t)
+
+(or (assq 'egg-conversion-mode egg-sub-mode-map-alist)
+    (setq egg-sub-mode-map-alist (cons
+				  '(egg-conversion-mode . egg-conversion-map)
+				  egg-sub-mode-map-alist)))
+
+(defun egg-conversion-enter/leave-fence (&optional old new)
+  (setq egg-conversion-mode (egg-conversion-fence-p)))
+
+(add-hook 'egg-enter/leave-fence-hook 'egg-conversion-enter/leave-fence)
+
 (defun egg-exit-conversion-unread-char ()
   (interactive)
-  (setq unread-command-events (list last-command-event)
-	this-command 'egg-use-context)
-  (setq egg-context (egg-exit-conversion)))
+  (setq egg-context (egg-exit-conversion)
+        unread-command-events (list last-command-event)
+	this-command 'egg-use-context))
 
 (defun egg-make-bunsetsu (backend bunsetsu last)
   (let* ((converted (copy-sequence (egg-get-bunsetsu-converted bunsetsu)))
@@ -597,27 +633,30 @@
 				    egg-conversion-minor-separator
 				  egg-conversion-major-separator))))
     (setq len (length converted))
-    (set-text-properties 0 len
+    (egg-remove-all-text-properties 0 len converted)
+    (add-text-properties 0 len
 			 (list 'read-only          t
 			       (egg-bunsetsu-info) bunsetsu
 			       'egg-backend        backend
 			       'egg-lang           language
 			       'egg-bunsetsu-last  last
 			       'egg-major-continue continue
-			       'local-map          'egg-conversion-map)
+			       'point-entered      'egg-enter/leave-fence
+			       'point-left         'egg-enter/leave-fence
+			       'modification-hooks '(egg-modify-fence))
 			 converted)
     (if face
 	(egg-set-face 0 len1 face converted))
     converted))
 
-(defun egg-insert-bunsetsu-list (backend bunsetsu-list &optional last)
+(defun egg-insert-bunsetsu-list (backend bunsetsu-list &optional last before)
   (let ((len (length bunsetsu-list)))
-    (insert
-     (mapconcat
-      (lambda (b)
-	(setq len (1- len))
-	(egg-make-bunsetsu backend b (and (= len 0) last)))
-      bunsetsu-list ""))))
+    (funcall (if before 'insert-before-markers 'insert)
+	     (mapconcat
+	      (lambda (b)
+		(setq len (1- len))
+		(egg-make-bunsetsu backend b (and (= len 0) last)))
+	      bunsetsu-list nil))))
 
 (defun egg-beginning-of-conversion-buffer (n)
   (interactive "p")
@@ -677,8 +716,7 @@
        (egg-get-bunsetsu-info (1- p))))
 
 (defun egg-get-previous-major-bunsetsu (p)
-  (let ((p (point))
-	(prev (egg-get-previous-bunsetsu p))
+  (let ((prev (egg-get-previous-bunsetsu p))
 	bunsetsu)
     (while prev
       (setq bunsetsu (cons prev bunsetsu)
@@ -702,7 +740,10 @@
     (nreverse bunsetsu)))
 
 (defsubst egg-get-major-bunsetsu-source (list)
-  (mapconcat (lambda (b) (egg-get-bunsetsu-source b)) list ""))
+  (mapconcat 'egg-get-bunsetsu-source list nil))
+
+(defsubst egg-get-major-bunsetsu-converted (list)
+  (mapconcat 'egg-get-bunsetsu-converted list nil))
 
 (defvar egg-inspect-mode nil
   "*Display clause information on candidate selection, if non-NIL.")
@@ -724,8 +765,8 @@
 (defvar egg-candidate-selection-major t)
 (make-variable-buffer-local 'egg-candidate-selection-major)
 
-(defsubst egg-set-candsel-info (b prev-b next-b major)
-  (setq egg-candidate-selection-info (list b prev-b next-b major)))
+(defsubst egg-set-candsel-info (b major)
+  (setq egg-candidate-selection-info (list (car b) (cadr b) (caddr b) major)))
 
 (defsubst egg-candsel-last-bunsetsu () (car egg-candidate-selection-info))
 (defsubst egg-candsel-last-prev-b () (nth 1 egg-candidate-selection-info))
@@ -744,9 +785,8 @@
 
 (defun egg-get-candsel-target-major ()
   (let ((bunsetsu (egg-get-major-bunsetsu (point)))
-	next-b prev-b next)
-    (setq prev-b (egg-get-previous-major-bunsetsu (point))
-	  next (egg-next-bunsetsu-point (point) (length bunsetsu)))
+	(prev-b (egg-get-previous-major-bunsetsu (point)))
+	next-b)
     (cond
      ((and (egg-candsel-last-major)
 	   (egg-major-bunsetsu-tail-p (egg-candsel-last-prev-b) prev-b)
@@ -755,31 +795,63 @@
 				      bunsetsu))
       (setq bunsetsu (egg-candsel-last-bunsetsu)
 	    prev-b (egg-candsel-last-prev-b)
-	    next-b (egg-candsel-last-next-b))
-      (setq next (egg-next-bunsetsu-point (point) (length bunsetsu))))
-     ((null (egg-get-bunsetsu-last (1- next)))
-      (setq next-b (egg-get-major-bunsetsu next))))
+	    next-b (egg-candsel-last-next-b)))
+     ((null (egg-get-bunsetsu-last
+	     (egg-next-bunsetsu-point (point) (1- (length bunsetsu)))))
+      (setq next-b (egg-get-major-bunsetsu
+		    (egg-next-bunsetsu-point (point) (length bunsetsu))))))
     (setq egg-candidate-selection-major t)
-    (list bunsetsu prev-b next-b next t)))
+    (list bunsetsu prev-b next-b t)))
 
 (defun egg-get-candsel-target-minor ()
   (let* ((bunsetsu (list (egg-get-bunsetsu-info (point))))
 	 (prev-b (egg-get-previous-bunsetsu (point)))
 	 (next-b (egg-get-next-bunsetsu (point))))
-    (and prev-b (setq prev-b (list prev-b)))
-    (and next-b (setq next-b (list next-b)))
     (setq egg-candidate-selection-major nil)
-    (list bunsetsu prev-b next-b (egg-next-bunsetsu-point (point)) nil)))
+    (list bunsetsu (and prev-b (list prev-b)) (and next-b (list next-b)) nil)))
 
-(defun egg-insert-new-bunsetsu (b prev-b next-b next end)
-  (let ((backend (egg-get-backend (point)))
-	start last)
-    (setq start (egg-previous-bunsetsu-point (point) (length prev-b)))
-    (setq end (or end (egg-next-bunsetsu-point next (length next-b))))
-    (setq last (egg-get-bunsetsu-last (1- end)))
-    (delete-region start end)
-    (egg-insert-bunsetsu-list backend (append prev-b (append b next-b)) last)
-    (goto-char (egg-next-bunsetsu-point start (length prev-b)))
+(defun egg-check-candsel-target (b prev-b next-b major)
+  (if major
+      (and (egg-major-bunsetsu-tail-p
+	    prev-b (egg-get-previous-major-bunsetsu (point)))
+	   (let* ((cur-b (egg-get-major-bunsetsu (point)))
+		  (next-p (egg-next-bunsetsu-point (point) (length cur-b))))
+	     (egg-major-bunsetsu-head-p
+	      (append b next-b)
+	      (append cur-b (and (null (egg-get-bunsetsu-last (1- next-p)))
+				 (egg-get-major-bunsetsu next-p))))))
+    (and (eq (egg-get-bunsetsu-info (point)) (car b))
+	 (eq (egg-get-previous-bunsetsu (point)) (car prev-b))
+	 (eq (egg-get-next-bunsetsu (point)) (car next-b)))))
+
+(defun egg-insert-new-bunsetsu (b tail new-b)
+  (let* ((backend (egg-get-backend (point)))
+	 (start (egg-previous-bunsetsu-point (point) (length (cadr new-b))))
+	 (end (egg-next-bunsetsu-point (point) (+ (length b) (length tail))))
+	 (last (egg-get-bunsetsu-last (1- end)))
+	 (insert-before (buffer-has-markers-at end)))
+    (cond
+     ((buffer-has-markers-at end)
+      (delete-region start end)
+      (egg-insert-bunsetsu-list backend
+				(append (cadr new-b) (car new-b) (caddr new-b))
+				last t))
+     ((buffer-has-markers-at (egg-next-bunsetsu-point (point) (length b)))
+      (delete-region start end)
+      (egg-insert-bunsetsu-list backend (append (cadr new-b) (car new-b))
+				nil t)
+      (egg-insert-bunsetsu-list backend (caddr new-b) last))
+     ((buffer-has-markers-at (point))
+      (delete-region start end)
+      (egg-insert-bunsetsu-list backend (cadr new-b) nil t)
+      (egg-insert-bunsetsu-list backend (append (car new-b) (caddr new-b))
+				last))
+     (t
+      (delete-region start end)
+      (egg-insert-bunsetsu-list backend
+				(append (cadr new-b) (car new-b) (caddr new-b))
+				last)))
+    (goto-char (egg-next-bunsetsu-point start (length (cadr new-b))))
     (if egg-inspect-mode
 	(egg-inspect-bunsetsu t))))
 
@@ -812,16 +884,19 @@
   (apply 'egg-next-candidate-internal (- n) (egg-get-candsel-target-minor)))
 
 (defvar egg-candidate-select-counter 1)
+(make-variable-buffer-local 'egg-candidate-select-counter)
 
-(defun egg-next-candidate-internal (n b prev-b next-b next major)
+(defun egg-next-candidate-internal (n b prev-b next-b major)
   (if (eq last-command (if major 'egg-candidate-major 'egg-candidate-minor))
       (setq egg-candidate-select-counter (1+ egg-candidate-select-counter))
     (setq egg-candidate-select-counter 1))
   (if (= egg-candidate-select-counter egg-conversion-auto-candidate-menu)
-      (egg-select-candidate-internal nil b prev-b next-b next major)
+      (egg-select-candidate-internal 
+       nil egg-conversion-auto-candidate-menu-show-all
+       b prev-b next-b major)
     (setq this-command (if major 'egg-candidate-major 'egg-candidate-minor))
     (let ((inhibit-read-only t)
-	  candidates nitem i beep)
+	  new-b candidates nitem i beep)
       (setq candidates (egg-list-candidates b prev-b next-b major))
       (if (null candidates)
 	  (setq beep t)
@@ -829,21 +904,18 @@
 	      nitem (length (cdr candidates)))
 	(cond
 	 ((< i 0)			; go backward as if it is ring
-	  (while (< i 0)
-	    (setq i (+ i nitem))))
+	  (setq i (% i nitem))
+	  (if (< i 0)
+	      (setq i (+ i nitem))))
 	 ((< i nitem))			; OK
 	 (egg-conversion-wrap-select	; go backward as if it is ring
-	  (while (>= i nitem)
-	    (setq i (- i nitem))))
+	  (setq i (% i nitem)))
 	 (t				; don't go forward 
 	  (setq i (1- nitem)
 		beep t)))
-	(setq b (egg-decide-candidate b i prev-b next-b)
-	      prev-b (nth 1 b)
-	      next-b (nth 2 b)
-	      b (car b))
-	(egg-set-candsel-info b prev-b next-b major)
-	(egg-insert-new-bunsetsu b prev-b next-b next nil))
+	(setq new-b (egg-decide-candidate b i prev-b next-b))
+	(egg-set-candsel-info new-b major)
+	(egg-insert-new-bunsetsu b (caddr new-b) new-b))
       (if beep
 	  (ding)))))
 
@@ -851,39 +923,65 @@
   (let ((n -1))
     (mapcar (lambda (item) (cons item (setq n (1+ n)))) list)))
 
-(defun egg-select-candidate-major ()
-  (interactive)
-  (apply 'egg-select-candidate-internal nil (egg-get-candsel-target-major)))
+(defun egg-sort-item (list sort)
+  (if (eq (null sort) (null egg-conversion-sort-by-converted-string))
+      list
+    (sort list (lambda (a b) (string< (car a) (car b))))))
 
-(defun egg-select-candidate-minor ()
-  (interactive)
-  (apply 'egg-select-candidate-internal nil (egg-get-candsel-target-minor)))
+(defun egg-select-candidate-major (sort)
+  (interactive "P")
+  (apply 'egg-select-candidate-internal sort nil (egg-get-candsel-target-major)))
 
-(defun egg-select-candidate-list-all-major ()
-  (interactive)
-  (apply 'egg-select-candidate-internal t (egg-get-candsel-target-major)))
+(defun egg-select-candidate-minor (sort)
+  (interactive "P")
+  (apply 'egg-select-candidate-internal sort nil (egg-get-candsel-target-minor)))
 
-(defun egg-select-candidate-list-all-minor ()
-  (interactive)
-  (apply 'egg-select-candidate-internal t (egg-get-candsel-target-minor)))
+(defun egg-select-candidate-list-all-major (sort)
+  (interactive "P")
+  (apply 'egg-select-candidate-internal sort t (egg-get-candsel-target-major)))
 
-(defun egg-select-candidate-internal (all b prev-b next-b next major)
-  (let ((inhibit-read-only t)
-	(prompt (egg-get-message 'candidate))
-	candidates item-list new i)
+(defun egg-select-candidate-list-all-minor (sort)
+  (interactive "P")
+  (apply 'egg-select-candidate-internal sort t (egg-get-candsel-target-minor)))
+
+(defun egg-select-candidate-internal (sort all b prev-b next-b major)
+  (let ((prompt (egg-get-message 'candidate))
+	new-b candidates pos clist item-list i)
     (setq candidates (egg-list-candidates b prev-b next-b major))
     (if (null candidates)
 	(ding)
-      (setq all (and all '(menudiag-list-all))
-	    item-list (egg-numbering-item (cdr candidates))
+      (setq pos (car candidates)
+	    clist (cdr candidates)
+	    item-list (egg-sort-item (egg-numbering-item clist) sort)
 	    i (menudiag-select (list 'menu prompt item-list)
-			       (cons (nth (car candidates) item-list) all))
-	    new (egg-decide-candidate b i prev-b next-b)
-	    prev-b (nth 1 new)
-	    next-b (nth 2 new)
-	    new (car new))
-      (egg-set-candsel-info new prev-b next-b major)
-      (egg-insert-new-bunsetsu new prev-b next-b next nil))))
+			       all
+			       (list (assq (nth pos clist) item-list))))
+      (if (or (null (egg-conversion-fence-p))
+	      (null (egg-check-candsel-target b prev-b next-b major)))
+	  (error "Fence was already modified")
+	(let ((inhibit-read-only t))
+	  (setq new-b (egg-decide-candidate b i prev-b next-b))
+	  (egg-set-candsel-info new-b major)
+	  (egg-insert-new-bunsetsu b (caddr new-b) new-b))))))
+
+(defun egg-hiragana (&optional minor)
+  (interactive "P")
+  (if (null minor)
+      (apply 'egg-special-convert this-command (egg-get-candsel-target-major))
+    (apply 'egg-special-convert this-command (egg-get-candsel-target-minor))))
+
+(defalias 'egg-katakana 'egg-hiragana)
+(defalias 'egg-pinyin 'egg-hiragana)
+(defalias 'egg-zhuyin 'egg-hiragana)
+(defalias 'egg-hangul 'egg-hiragana)
+
+(defun egg-special-convert (type b prev-b next-b major)
+  (let ((inhibit-read-only t)
+	(new-b (egg-special-candidate b prev-b next-b major type)))
+    (if (null new-b)
+	(ding)
+      (egg-set-candsel-info new-b major)
+      (egg-insert-new-bunsetsu b (caddr new-b) new-b))))
 
 (defun egg-separate-characters (str)
   (let* ((v (egg-string-to-vector str))
@@ -915,7 +1013,7 @@
 
 (defun egg-enlarge-bunsetsu-internal (n major)
   (let ((inhibit-read-only t)
-	b prev-b next-b s1 s1len s2 s2len nchar i last next end beep)
+	b prev-b next-b new-b s1 s1len s2 s2len nchar i last end beep)
     (if major
 	(setq b (egg-get-major-bunsetsu (point))
 	      prev-b (egg-get-previous-major-bunsetsu (point)))
@@ -938,28 +1036,23 @@
      ((<= n 0)
       (setq beep t nchar (and (/= s1len 1) (egg-get-char-size 0 s1))))
      ((> n s2len)
-      (setq beep t nchar (and (/= s2len 0) (length s2))))
+      (setq beep t nchar (and (/= s2len s1len) (length s2))))
      (t
       (setq nchar 0)
       (while (> n 0)
 	(setq nchar (+ nchar (egg-get-char-size nchar s2))
 	      n (1- n)))))
-    (if nchar
-	(progn
-	  (setq next-b (nconc b next-b)
-		i (length (egg-get-bunsetsu-source (car next-b))))
-	  (while (< i nchar)
-	    (setq next-b (cdr next-b)
-		  i (+ i (length (egg-get-bunsetsu-source (car next-b))))))
-	  (setq next-b (prog1 (cdr next-b) (setcdr next-b nil))
-		next (egg-next-bunsetsu-point (point) (length b))
-		b (egg-change-bunsetsu-length b prev-b next-b nchar major))
-	  (if (null b)
-	      (setq beep t)
-	    (setq prev-b (nth 1 b)
-		  next-b (nth 2 b)
-		  b (car b))
-	    (egg-insert-new-bunsetsu b prev-b next-b next (and next-b end)))))
+    (when nchar
+      (setq next-b (nconc b next-b)
+	    i (length (egg-get-bunsetsu-source (car next-b))))
+      (while (< i nchar)
+	(setq next-b (cdr next-b)
+	      i (+ i (length (egg-get-bunsetsu-source (car next-b))))))
+      (setq next-b (prog1 (cdr next-b) (setcdr next-b nil))
+	    new-b (egg-change-bunsetsu-length b prev-b next-b nchar major))
+      (if (null new-b)
+	  (setq beep t)
+	(egg-insert-new-bunsetsu b (and (caddr new-b) next-b) new-b)))
     (if beep
 	(ding))))
 
@@ -1028,9 +1121,7 @@
       (if (or (= i len)
 	      (egg-get-bunsetsu-last (1- i) decided))
 	  (progn
-	    (apply 'insert (mapcar
-			    (lambda (b) (egg-get-bunsetsu-converted b))
-			    bunsetsu))
+	    (insert (mapconcat 'egg-get-bunsetsu-converted bunsetsu nil))
 	    (setq context (cons (cons (egg-bunsetsu-get-backend (car bunsetsu))
 				      (egg-end-conversion bunsetsu nil))
 				context)
@@ -1071,7 +1162,7 @@
 
 (defun egg-exit-conversion ()
   (interactive)
-  (if (egg-get-bunsetsu-info (point))
+  (if (egg-conversion-fence-p)
       (progn
 	(goto-char (next-single-property-change (point) 'egg-end))
 	(egg-decide-before-point))))
diff -u -3 ../tamago-4.0.6/egg-com.el ./egg-com.el
--- ../tamago-4.0.6/egg-com.el	Tue Jan  4 15:49:56 2000
+++ ./egg-com.el
@@ -136,6 +136,7 @@
 		    (cons ccl-decode-fixed-euc-kr ccl-encode-fixed-euc-kr))
 
 ;; Chinese
+
 (defconst egg-pinyin-shengmu
   '((""  . 0)  ("B" . 1)  ("C"  . 2)  ("Ch" . 3)  ("D" . 4)
     ("F" . 5)  ("G" . 6)  ("H"  . 7)  ("J"  . 8)  ("K" . 9)
@@ -521,53 +522,60 @@
 (defun decode-fixed-euc-china-region (beg end type zhuyin)
   "Decode EUC-CN/TW encoded text in the region.
 Return the length of resulting text."
-  (prog1
-      (let ((str (string-as-unibyte (buffer-substring beg end)))
-	    (i 0)
-	    l c0 c1 s y ss)
-	(delete-region beg end)
-	(setq l (1- (length str)))
-	(while (< i l)
-	  (setq c0 (aref str i)
-		c1 (aref str (1+ i))
-		i  (+ i 2))
-	  (cond
-	   ((eq c0 0)
-	    (if (> c1 ?\xa0)
-		(insert leading-code-private-11
-			(charset-id 'chinese-sisheng)
-			c1)
-	      (insert c1)))
-	   ((>= c0 ?\x80)
-	    (cond
-	     ((eq type 'cn)
-	      (insert (charset-id 'chinese-gb2312) c0 (logior c1 ?\x80)))
-	     ((>= c1 ?\x80)
-	      (insert (charset-id 'chinese-cns11643-1) c0 c1))
-	     (t
-	      (insert (charset-id 'chinese-cns11643-2) c0 (+ c1 ?\x80)))))
-	   (t
-	    (setq c1 (logand c1 ?\x7f))
-	    (setq s (- (lsh c1 -2) 7);;(+ (lsh (- c1 32) -2) 1)
-		  y (- (lsh c0 -1) 16);;(lsh (- c0 32) -1)
-		  ss (+ (logand c0 1) (logand c1 3)))
-	    (if (and (eq s 20)
-		     (eq (aref egg-pinyin-table (+ (* 39 20) y)) 0))
-		(setq s 0))
-	    (if (null zhuyin)
-		(setq s (car (nth s egg-pinyin-shengmu))
-		      y (car (nth (+ (* 5 y) ss) egg-pinyin-yunmu)))
-	      (setq c0 (aref egg-zhuyin-table (+ (* 41 s) y)))
-	      (if (eq (logand c0 ?\x8080) ?\x80)
-		  (setq s (lsh c0 -8)
-			y (logand c0 ?\x7f)))
-	      (setq s (car (nth s egg-zhuyin-shengmu))
-		    y (car (nth (+ (* 5 y) ss) egg-zhuyin-yunmu))))
-	    (if enable-multibyte-characters
-		(insert s y)
-	      (insert (string-as-unibyte s) (string-as-unibyte y))))))
-	(- (point) beg))
-    (if (looking-at "\0\0") (forward-char 2))))
+  (let ((str (string-as-unibyte (buffer-substring beg end)))
+	(i 0)
+	(char (make-string 3 0))
+	l c0 c1 s y ss)
+    (delete-region beg end)
+    (setq l (1- (length str)))
+    (while (< i l)
+      (setq c0 (aref str i)
+	    c1 (aref str (1+ i))
+	    i  (+ i 2))
+      (cond
+       ((eq c0 0)
+	(if (<= c1 ?\xa0)
+	    (insert c1)
+	  (aset char 0 leading-code-private-11)
+	  (aset char 1 (charset-id 'chinese-sisheng))
+	  (aset char 2 c1)
+	  (insert (string-as-multibyte char))))
+       ((>= c0 ?\x80)
+	(cond
+	 ((eq type 'cn)
+	  (aset char 0 (charset-id 'chinese-gb2312))
+	  (aset char 1 c0)
+	  (aset char 2 (logior c1 ?\x80)))
+	 ((>= c1 ?\x80)
+	  (aset char 0 (charset-id 'chinese-cns11643-1))
+	  (aset char 1 c0)
+	  (aset char 2 c1))
+	 (t
+	  (aset char 0 (charset-id 'chinese-cns11643-2))
+	  (aset char 1 c0)
+	  (aset char 2 (+ c1 ?\x80))))
+	(insert (string-as-multibyte char)))
+       (t
+	(setq c1 (logand c1 ?\x7f))
+	(setq s (- (lsh c1 -2) 7);;(+ (lsh (- c1 32) -2) 1)
+	      y (- (lsh c0 -1) 16);;(lsh (- c0 32) -1)
+	      ss (+ (logand c0 1) (logand c1 3)))
+	(if (and (eq s 20)
+		 (eq (aref egg-pinyin-table (+ (* 39 20) y)) 0))
+	    (setq s 0))
+	(if (null zhuyin)
+	    (setq s (car (nth s egg-pinyin-shengmu))
+		  y (car (nth (+ (* 5 y) ss) egg-pinyin-yunmu)))
+	  (setq c0 (aref egg-zhuyin-table (+ (* 41 s) y)))
+	  (if (eq (logand c0 ?\x8080) ?\x80)
+	      (setq s (lsh c0 -8)
+		    y (logand c0 ?\x7f)))
+	  (setq s (car (nth s egg-zhuyin-shengmu))
+		y (car (nth (+ (* 5 y) ss) egg-zhuyin-yunmu))))
+	(if enable-multibyte-characters
+	    (insert s y)
+	  (insert (string-as-unibyte s) (string-as-unibyte y))))))
+    (- (point) beg)))
 
 (defun post-read-decode-fixed-euc-china (len type zhuyin)
   (let ((pos (point))
@@ -620,7 +628,7 @@
 
 (eval-and-compile
 (define-ccl-program ccl-decode-egg-binary
-  `(2
+  `(1
     ((read r0)
      (loop
       (if (r0 == ?\xff)
@@ -628,7 +636,7 @@
       (write-read-repeat r0)))))
 
 (define-ccl-program ccl-encode-egg-binary
-  `(1
+  `(2
     ((read r0)
      (loop
       (if (r0 == ?\xff)
@@ -705,6 +713,7 @@
 u: 32-bit integer.  The argument is treat as unsigned integer.
    (Note:  Elisp's integer may be less than 32 bits)
 i: 32-bit integer.
+   (Note:  Elisp's integer may be greater than 32 bits)
 w: 16-bit integer.
 b: 8-bit integer.
 S: 16-bit wide-character EUC string (0x0000 terminated).
@@ -776,6 +785,14 @@
 	  (+ (lsh (comm-following+forward-char) 8)
 	     (comm-following+forward-char)))))
 
+(defun comm-unpack-i32 ()
+  (progn
+    (comm-require-process-output 4)
+    (+ (lsh (- (logxor (comm-following+forward-char) 128) 128) 24)
+       (lsh (comm-following+forward-char) 16)
+       (lsh (comm-following+forward-char) 8)
+       (comm-following+forward-char))))
+
 (defun comm-unpack-u32 ()
   (progn
     (comm-require-process-output 4)
@@ -852,7 +869,7 @@
 	     (list
 	      (cond ((eq f 'U) `(setq ,arg (comm-unpack-u32c)))
 		    ((eq f 'u) `(setq ,arg (comm-unpack-u32)))
-		    ((eq f 'i) `(setq ,arg (comm-unpack-u32)))
+		    ((eq f 'i) `(setq ,arg (comm-unpack-i32)))
 		    ((eq f 'w) `(setq ,arg (comm-unpack-u16)))
 		    ((eq f 'b) `(setq ,arg (comm-unpack-u8)))
 		    ((eq f 'S) `(setq ,arg (comm-unpack-u16-string)))
Only in ../tamago-4.0.6: egg-sim-old.el
diff -u -3 ../tamago-4.0.6/egg-sim.el ./egg-sim.el
--- ../tamago-4.0.6/egg-sim.el	Mon Jan 17 01:51:34 2000
+++ ./egg-sim.el
@@ -73,7 +73,7 @@
 		result)))))
 
 (defvar egg-sim-ascii-menu
-  '(menu "ASCII:" ,(make-char-list 'ascii)))
+  `(menu "ASCII:" ,(make-char-list 'ascii)))
 
 (defvar egg-sim-latin-1-menu
   `(menu "ISO 8859-1:" ,(make-char-list 'latin-iso8859-1)))
@@ -355,7 +355,7 @@
   `(menu "Character set:" , egg-simple-input-method-menu-item-list))
 
 ;;;;###autoload
-(defun egg-simple-input-method()
+(defun egg-simple-input-method ()
   (interactive)
   (let ((result (egg-simple-input-menu)))
     (cond((stringp result)
@@ -545,4 +545,4 @@
 			    (+ j 32 128)))
 	    (setq j (1+ j)))
 	  (insert (format "\n")))
-	(setq i (1+ i))))))
+	(setq i (1+ i))))))
Only in ../tamago-4.0.6: egg-simv.el
diff -u -3 ../tamago-4.0.6/egg.el ./egg.el
--- ../tamago-4.0.6/egg.el	Mon Jan 17 09:36:17 2000
+++ ./egg.el
@@ -33,10 +33,11 @@
 (require 'cl)
 (require 'egg-edep)
 
-(autoload 'egg-simple-input-method "egg-sim")
+(autoload 'egg-simple-input-method "egg-sim"
+  "simple input method for Tamago 4." t)
 
 (defgroup egg nil
-  "Tamago Version 4")
+  "Tamago Version 4.")
 
 (defcustom egg-mode-preference t
   "*Make Egg as modefull input method, if non-NIL."
@@ -48,9 +49,84 @@
 (make-variable-buffer-local 'egg-last-method-name)
 (put 'egg-last-method-name 'permanent-local t)
 
-(defvar egg-current-keymap nil)
-(make-variable-buffer-local 'egg-current-keymap)
-(put 'egg-current-keymap 'permanent-local t)
+(defvar egg-mode-map-alist nil)
+(defvar egg-sub-mode-map-alist nil)
+
+(defmacro define-egg-mode-map (mode &rest initializer)
+  (let ((map (intern (concat "egg-" (symbol-name mode) "-map")))
+	(var (intern (concat "egg-" (symbol-name mode) "-mode")))
+	(comment (concat (symbol-name mode) " keymap for EGG mode.")))
+    `(progn
+       (defvar ,map (let ((map (make-sparse-keymap)))
+		      ,@initializer
+		      map)
+	 ,comment)
+       (fset ',map ,map)
+       (defvar ,var nil)
+       (make-variable-buffer-local ',var)
+       (put ',var 'permanent-local t)
+       (or (assq ',var egg-mode-map-alist)
+	   (setq egg-mode-map-alist (append egg-mode-map-alist
+					    '((,var . ,map))))))))
+
+(define-egg-mode-map modefull
+  (define-key map "\C-^" 'egg-simple-input-method)
+  (let ((i 33))
+    (while (< i 127)
+      (define-key map (vector i) 'egg-self-insert-char)
+      (setq i (1+ i)))))
+
+(define-egg-mode-map modeless
+  (define-key map " " 'mlh-space-bar-backward-henkan)
+  (define-key map "\C-^" 'egg-simple-input-method))
+
+(defvar egg-enter/leave-fence-hook nil)
+
+(defun egg-enter/leave-fence (&optional old new)
+  (run-hooks 'egg-enter/leave-fence-hook))
+
+(defvar egg-activated nil)
+(make-variable-buffer-local 'egg-activated)
+(put 'egg-activated 'permanent-local t)
+
+(defun egg-activate-keymap ()
+  (when (and egg-activated
+	     (null (eq (car egg-sub-mode-map-alist)
+		       (car minor-mode-overriding-map-alist))))
+    (let ((alist (append egg-sub-mode-map-alist egg-mode-map-alist))
+	  (overriding (copy-sequence minor-mode-overriding-map-alist)))
+      (while alist
+	(setq overriding (delq (assq (caar alist) overriding) overriding)
+	      alist (cdr alist)))
+      (setq minor-mode-overriding-map-alist (append egg-sub-mode-map-alist
+						    overriding
+						    egg-mode-map-alist)))))
+
+(add-hook 'egg-enter/leave-fence-hook 'egg-activate-keymap t)
+
+(defun egg-modify-fence (&rest arg)
+  (add-hook 'post-command-hook 'egg-post-command-func))
+
+(defun egg-post-command-func ()
+  (run-hooks 'egg-enter/leave-fence-hook)
+  (remove-hook 'post-command-hook 'egg-post-command-func))
+
+(defvar egg-change-major-mode-buffer nil)
+
+(defun egg-activate-keymap-after-command ()
+  (while egg-change-major-mode-buffer
+    (save-excursion
+      (set-buffer (car egg-change-major-mode-buffer))
+      (egg-activate-keymap)
+      (setq egg-change-major-mode-buffer (cdr egg-change-major-mode-buffer))))
+  (remove-hook 'post-command-hook 'egg-activate-keymap-after-command))
+
+(defun egg-change-major-mode-func ()
+  (setq egg-change-major-mode-buffer (cons (current-buffer)
+					   egg-change-major-mode-buffer))
+  (add-hook 'post-command-hook 'egg-activate-keymap-after-command))
+
+(add-hook 'change-major-mode-hook 'egg-change-major-mode-func)
 
 ;;;###autoload
 (defun egg-mode (&rest arg)
@@ -64,9 +140,9 @@
 	  (progn
 	    (its-exit-mode)
 	    (egg-exit-conversion))
-	(setq describe-current-input-method-function nil)
-	(if (eq (current-local-map) egg-current-keymap)
-	    (use-local-map (keymap-parent (current-local-map))))
+	(setq describe-current-input-method-function nil
+	      egg-modefull-mode nil
+	      egg-modeless-mode nil)
 	(remove-hook 'input-method-activate-hook 'its-set-mode-line-title t)
 	(force-mode-line-update))
     ;; Turn on
@@ -77,11 +153,14 @@
     (egg-set-conversion-backend (nthcdr 2 arg))
     (egg-set-conversion-backend
      (list (assq its-current-language (nthcdr 2 arg))) t)
-    (setq egg-last-method-name (car arg))
-    (setq egg-current-keymap (if egg-mode-preference
-				 (egg-modefull-map)
-			       (egg-modeless-map)))
-    (use-local-map egg-current-keymap)
+    (setq egg-last-method-name (car arg)
+	  egg-activated t)
+    (egg-activate-keymap)
+    (if egg-mode-preference
+	(progn
+	  (setq egg-modefull-mode t)
+	  (its-define-select-keys egg-modefull-map))
+      (setq egg-modeless-mode t))
     (setq inactivate-current-input-method-function 'egg-mode)
     (setq describe-current-input-method-function 'egg-help)
     (make-local-hook 'input-method-activate-hook)
@@ -95,43 +174,37 @@
   (if (<= (minibuffer-depth) 1)
       (remove-hook 'minibuffer-exit-hook 'egg-exit-from-minibuffer)))
 
-(defun egg-modefull-map ()
-  "Generate modefull keymap for EGG mode."  
-  (let ((map (make-sparse-keymap))
-	(i 33))
-    (define-key map "\C-^" 'egg-simple-input-method)
-    (while (< i 127)
-      (define-key map (vector i) 'egg-self-insert-char)
-      (setq i (1+ i)))
-    (its-define-select-keys map)
-    (set-keymap-parent map (current-local-map))
-    map))
-
-(defun egg-modeless-map ()
-  "Generate modeless keymap for EGG mode."
-  (let ((map (make-sparse-keymap)))
-    (define-key map " " 'mlh-space-bar-backward-henkan)
-    (define-key map "\C-^" 'egg-simple-input-method)
-    (set-keymap-parent map (current-local-map))
-    map))
-
 (defvar egg-context nil)
 
 (defun egg-self-insert-char ()
   (interactive)
   (its-start last-command-char (and (eq last-command 'egg-use-context)
 				    egg-context)))
+
+(defun egg-remove-all-text-properties (from to &optional object)
+  (let ((p from)
+	props prop)
+    (while (< p to)
+      (setq prop (text-properties-at p object))
+      (while prop
+	(unless (eq (car prop) 'composition)
+	  (setq props (plist-put props (car prop) nil)))
+	(setq prop (cddr prop)))
+      (setq p (next-property-change p object to)))
+    (remove-text-properties from to props object)))
 
 (defvar egg-mark-list nil)
 (defvar egg-suppress-marking nil)
 
 (defun egg-set-face (beg eng face &optional object)
-  (put face 'face face)
-  (add-text-properties beg eng
-		       (list 'category face
-			     'egg-face t
-			     'modification-hooks '(egg-mark-modification))
-		       object))
+  (let ((hook (get-text-property beg 'modification-hooks object)))
+    (put face 'face face)
+    (add-text-properties beg eng
+			 (list 'category face
+			       'egg-face t
+			       'modification-hooks (cons 'egg-mark-modification
+							 hook))
+			 object)))
 
 (defun egg-mark-modification (beg end)
   (if (and (null egg-suppress-marking)
Only in ../tamago-4.0.6: egg.el.orig
diff -u -3 ../tamago-4.0.6/eggrc ./eggrc
--- ../tamago-4.0.6/eggrc	Tue Jan  4 15:50:44 2000
+++ ./eggrc
@@ -1,4 +1,4 @@
-;;; eggrc --- EGG Input Method Startup File
+;;; eggrc --- EGG Input Method Startup File -*- emacs-lisp -*-
 
 ;; Copyright (C) 1999, 2000 Free Software Foundation, Inc
 
@@ -186,11 +186,15 @@
     (wnn-add-dict '("ud")                nil             2 t   t)
     (wnn-set-param 2 5 2 45 200 80 5 1 40 0 400 -100 400 80 200 2 200))))
 
- ((eq egg-backend-type 'sj3)
-;  (sj3-set-default-sys-dic-directory "/usr/sony/dict/sj3")
-;  (sj3-set-default-usr-dic-directory "/usr/sony/dict/sj3/user/$USER")
+ ((eq egg-backend-type 'canna)
 
-  (sj3-setsysdic "sj3main.dic")
-
-  (sj3-setusrdic "private.dic")
-  (sj3-setusrstdy "study.dat")))
+  (canna-define-environment)
+  (canna-add-dict "iroha" nil)
+  (canna-add-dict "fuzokugo" nil)
+  (canna-add-dict "hojomwd" nil)
+  (canna-add-dict "hojoswd" nil)
+  (canna-add-dict "user" t)
+
+  (canna-define-environment "Bushu" 0 t)
+  (canna-add-dict "bushu" nil))
+ )
Common subdirectories: ../tamago-4.0.6/its and ./its
diff -u -3 ../tamago-4.0.6/its-keydef.el ./its-keydef.el
--- ../tamago-4.0.6/its-keydef.el	Wed Jan  5 13:43:30 2000
+++ ./its-keydef.el
@@ -70,7 +70,7 @@
 	     ((its-in-fence-p)
 	      (its-input-end)
 	      (its-put-cursor t))
-	     ((egg-get-bunsetsu-info (point))
+	     ((egg-conversion-fence-p)
 	      (egg-exit-conversion)))
 	    (setq its-current-select-func func
 		  its-current-map ',map
diff -u -3 ../tamago-4.0.6/its.el ./its.el
--- ../tamago-4.0.6/its.el	Mon Jan 17 09:36:17 2000
+++ ./its.el
@@ -35,7 +35,7 @@
 (require 'egg-edep)
 
 (defgroup its nil
-  "Input Translation System of Tamagotchy"
+  "Input Translation System of Tamago 4."
   :group 'egg)
 
 (defcustom its-enable-fullwidth-alphabet t
@@ -194,8 +194,15 @@
 (defsubst its-kst-p (kst/t)
   (not (or (numberp kst/t) (null kst/t))))
 
-(defsubst its-get-output (syl/state)
-  (car syl/state))
+(defun its-get-output (syl/state &optional no-eval)
+  (setq syl/state (car syl/state))
+  (cond ((null (consp syl/state))
+	 syl/state)
+	((and (null no-eval) (eq (car syl/state) 'eval))
+	 (eval (mapcar (lambda (s) (if (stringp s) (copy-sequence s) s))
+		       (cdr syl/state))))
+	(t
+	 (copy-sequence syl/state))))
 
 (defsubst its-set-output (state output)
   (setcar state output))
@@ -274,13 +281,26 @@
     (define-key map "\M-n" 'its-next-map)
     (define-key map "\M-h" 'its-hiragana) ; hiragana-region for input-buffer
     (define-key map "\M-k" 'its-katakana)
-    (define-key map "\M-<" 'its-hankaku)
-    (define-key map "\M->" 'its-zenkaku)
+    (define-key map "\M-<" 'its-half-width)
+    (define-key map "\M->" 'its-full-width)
     map)
   "Keymap for ITS mode.")
-
 (fset 'its-mode-map its-mode-map)
 
+(defvar its-fence-mode nil)
+(make-variable-buffer-local 'its-fence-mode)
+(put 'its-fence-mode 'permanent-local t)
+
+(defvar egg-sub-mode-map-alist nil)
+(or (assq 'its-fence-mode egg-sub-mode-map-alist)
+    (setq egg-sub-mode-map-alist (cons '(its-fence-mode . its-mode-map)
+				       egg-sub-mode-map-alist)))
+
+(defun its-enter/leave-fence (&optional old new)
+  (setq its-fence-mode (its-in-fence-p)))
+
+(add-hook 'egg-enter/leave-fence-hook 'its-enter/leave-fence)
+
 (defconst its-setup-fence-before-insert-SYL nil)
 
 (defun its-get-fence-face (lang)
@@ -290,17 +310,19 @@
 	     (assq t its-fence-face)))))
 
 (defun its-put-cursor (cursor)
-  (if (null (eq its-barf-on-invalid-keyseq 'its-keyseq-test))
-      (let ((p (point))
-	    (str (copy-sequence "!")))
-	(set-text-properties 0 1 (list 'local-map 'its-mode-map
-				       'read-only t
-				       'invisible t
-				       'intangible 'its-part-2
-				       'its-cursor cursor)
-			     str)
-	(insert str)
-	(goto-char p))))
+  (unless (eq its-barf-on-invalid-keyseq 'its-keyseq-test)
+    (let ((p (point))
+	  (str (copy-sequence "!")))
+      (set-text-properties 0 1 (list 'read-only          t
+				     'invisible          t
+				     'intangible         'its-part-2
+				     'its-cursor         cursor
+				     'point-entered      'egg-enter/leave-fence
+				     'point-left         'egg-enter/leave-fence
+				     'modification-hooks '(egg-modify-fence))
+			   str)
+      (insert str)
+      (goto-char p))))
 
 (defun its-set-cursor-status (cursor)
   (delete-region (point) (1+ (point)))
@@ -643,14 +665,14 @@
 	 (add-hook hook func t)
        (funcall func)
        (run-hooks hook)
-       (setq hook nil))))
+       (set hook nil))))
 
 ;; Data structure for map compaction
 ;;  <node> ::= (<count> <node#> <original node>)   ; atom
 ;;          |  (<count> <node#> (<node> . <node>)) ; cons cell
 ;;
 ;;  <count> ::= integer  ; 0 or negative - usage count
-;;                       ; psotive       - generated common sub-tree
+;;                       ; positive      - generated common sub-tree
 ;;
 ;;  <node#> ::= integer  ; subject to compaction
 ;;           |  nil      ; not subject to compaction
@@ -683,9 +705,16 @@
   `(1- (setq its-compaction-list (cons ,node its-compaction-list)
 	     its-compaction-counter-2 (1+ its-compaction-counter-2))))
 
+(defmacro its-concat (&rest args)
+  `(concat ,@(mapcar (lambda (arg)
+		       (if (stringp arg)
+			   arg
+			 `(if (numberp ,arg) (number-to-string ,arg) ,arg)))
+		     args)))
+
 (defmacro its-compaction-hash (name node parent lr type)
   (if (null type)
-      `(let ((hash (intern (concat ,@name) its-compaction-hash-table)))
+      `(let ((hash (intern (its-concat ,@name) its-compaction-hash-table)))
 	 (if (null (boundp hash))
 	     (car (set hash (list* (its-compaction-new-node) ,parent ,lr)))
 	   (setq hash (symbol-value hash))
@@ -696,7 +725,7 @@
 	   (its-compaction-set-lr ,parent ,lr (cdr hash))
 	   (car hash)))
     `(let ((hash ,(if (eq type 'integer)
-		      `(intern (concat ,@name) its-compaction-hash-table)
+		      `(intern (its-concat ,@name) its-compaction-hash-table)
 		    `(aref its-compaction-integer-table (+ ,node 10)))))
        (if (null ,(if (eq type 'integer) '(boundp hash) 'hash))
 	   (setq hash (,@(if (eq type 'integer)
@@ -708,18 +737,24 @@
        (its-compaction-set-lr ,parent ,lr (cdr hash))
        (car hash))))
 
-(defun its-map-compaction-internal (map parent lr)
+(defun its-map-compaction-internal (map parent lr &optional force)
   (cond
-   ((consp map)    (let ((candidate (or (null (stringp (car map))) (cdr map)))
-			 (l (its-map-compaction-internal (car map) map 'car))
-			 (r (its-map-compaction-internal (cdr map) map 'cdr)))
-		     (if (and candidate l r)
-			 (its-compaction-hash (l " " r) map parent lr nil))))
-   ((stringp map)  (its-compaction-hash ("STR" map) map parent lr nil))
-   ((integerp map) (if (and (>= map -10) (< map 128))
-		       (its-compaction-hash nil map parent lr small-int)
-		     (its-compaction-hash ("INT" map) map parent lr integer)))
-   ((null map)     0)))
+   ((consp map)
+    (let* ((candidate (or (null (stringp (car map))) (cdr map)))
+	   (sexp (or force (eq (car map) 'eval)))
+	   (l (its-map-compaction-internal (car map) map 'car sexp))
+	   (r (its-map-compaction-internal (cdr map) map 'cdr sexp)))
+      (if (or sexp (and candidate l r))
+	  (its-compaction-hash (l " " r) map parent lr nil))))
+   ((stringp map)
+    (its-compaction-hash ("STR" map) map parent lr nil))
+   ((integerp map)
+    (if (and (>= map -10) (< map 128))
+	(its-compaction-hash nil map parent lr small-int)
+      (its-compaction-hash ("INT" map) map parent lr integer)))
+   ((null map) 0)
+   ((symbolp map)
+    (its-compaction-hash ("SYM" (symbol-name map)) map parent lr nil))))
 
 (defvar its-map-rebuild-subtrees)
 
@@ -802,7 +837,7 @@
     state))
 
 (defun its-set-interim-terminal-state (state &optional output)
-  (its-make-next-state state -1 (or output (its-get-output state)))
+  (its-make-next-state state -1 (or output (its-get-output state t)))
   (its-defrule-otherwise state output))
 
 (defun its-defoutput (input display)
@@ -1124,10 +1159,14 @@
     (setq i 0)
     (while (< i len)
       (setq lang (get-text-property i 'egg-lang source))
-      (if (and
-	   (or (eq lang 'Chinese-GB) (eq lang 'Chinese-CNS))
-	   (setq l (egg-chinese-syllable source i)))
-	  (setq j (+ i l))
+      (if (or (and (or (eq lang 'Chinese-GB) (eq lang 'Chinese-CNS))
+		   (setq l (egg-chinese-syllable source i)))
+	      (and (setq l (get-text-property i 'composition source))
+		   (setq l (if (consp (car l)) (caar l) (cadr l)))
+		   (eq (next-single-property-change i 'composition
+						    source (length source))
+		       l)))
+	     (setq j (+ i l))
 	(setq j (+ i (egg-char-bytes (egg-string-to-char-at source i)))))
       (setq syl (substring no-prop-source i j))
       (put-text-property i j 'its-syl (cons syl syl) source)
@@ -1181,7 +1220,7 @@
 
 ;; TODO: handle overwrite-mode, insertion-hook, fill...
 (defun its-exit-mode-internal (&optional proceed-to-conversion n)
-  (let (start end s context)
+  (let (start end s context str)
     (its-select-previous-mode t)
     ;; Delete CURSOR
     (delete-region (point) (1+ (point)))
@@ -1198,9 +1237,10 @@
 	(egg-convert-region start end context n)
       ;; Remove all properties
       (goto-char start)
-      (insert (prog1
-		  (buffer-substring-no-properties start end)
-		(delete-region start end)))
+      (setq str (buffer-substring start end))
+      (egg-remove-all-text-properties 0 (length str) str)
+      (delete-region start end)
+      (insert str)
       (egg-do-auto-fill)
       (run-hooks 'input-method-after-insert-chunk-hook))))
 
@@ -1220,7 +1260,8 @@
       (its-kick-convert-region n))))
 
 (defun its-in-fence-p ()
-  (eq (get-text-property (point) 'intangible) 'its-part-2))
+  (and (eq (get-text-property (point) 'intangible) 'its-part-2)
+       (get-text-property (point) 'read-only)))
 
 (defvar its-translation-result "" "")
 
@@ -1241,7 +1282,7 @@
 (defun its-translate-region (start end)
   (interactive "r")
   (its-translate-region-internal start end)
-  (set-text-properties start (point) nil))
+  (egg-remove-all-text-properties start (point)))
 
 (defun its-translate-region-internal (start end)
   (setq its-translation-result "")
@@ -1300,66 +1341,198 @@
 ;;; its-hiragana : hiragana-region for input-buffer
 (defun its-hiragana ()
   (interactive)
-  (let ((inhibit-read-only t))
-    (its-input-end)
-    (its-set-part-1 (point) (its-search-end))
-    (its-convert 'japanese-hiragana (its-search-beginning) (point))
-    (its-put-cursor t)))
+  (its-convert (lambda (str lang) (japanese-hiragana str))))
 
 ;;; its-katakana : katanaka-region for input-buffer
 (defun its-katakana ()
   (interactive)
-  (let ((inhibit-read-only t))
-    (its-input-end)
-    (its-set-part-1 (point) (its-search-end))
-    (its-convert 'japanese-katakana (its-search-beginning) (point))
-    (its-put-cursor t)))
+  (its-convert (lambda (str lang) (japanese-katakana str))))
 
-;;; its-hankaku : hankaku-region for input-buffer
-(defun its-hankaku ()
-  (interactive)
-  (let ((inhibit-read-only t))
-    (its-input-end)
-    (its-set-part-1 (point) (its-search-end))
-    (its-convert 'its-japanese-hankaku (its-search-beginning) (point))
-    (its-put-cursor t)))
+(defconst its-full-half-table (make-vector 100 nil))
+(defconst its-half-full-table (make-vector 100 nil))
 
-(defun its-japanese-hankaku (obj)
-  (japanese-hankaku obj 'ascii-only))
+(let ((table '((Japanese
+		(?$B!!(B . ?\ ) (?$B!$(B . ?,)  (?$B!%(B . ?.)  (?$B!"(B . ?,)  (?$B!#(B . ?.)
+		(?$B!'(B . ?:)  (?$B!((B . ?\;) (?$B!)(B . ??)  (?$B!*(B . ?!)
+		(?$B!-(B . ?')  (?$B!.(B . ?`)  (?$B!0(B . ?^)  (?$B!2(B . ?_)  (?$B!1(B . ?~)
+		(?$B!<(B . ?-)  (?$B!=(B . ?-)  (?$B!>(B . ?-)
+		(?$B!?(B . ?/)  (?$B!@(B . ?\\) (?$B!A(B . ?~)  (?$B!C(B . ?|)
+		(?$B!F(B . ?`)  (?$B!G(B . ?')  (?$B!H(B . ?\") (?$B!I(B . ?\")
+		(?$B!J(B . ?\() (?$B!K(B . ?\)) (?$B!N(B . ?[)  (?$B!O(B . ?])
+		(?$B!P(B . ?{)  (?$B!Q(B . ?})  (?$B!R(B . ?<)  (?$B!S(B . ?>)
+		(?$B!\(B . ?+)  (?$B!](B . ?-)  (?$B!a(B . ?=)  (?$B!c(B . ?<)  (?$B!d(B . ?>)
+		(?$B!l(B . ?')  (?$B!m(B . ?\") (?$B!o(B . ?\\) (?$B!p(B . ?$)  (?$B!s(B . ?%)
+		(?$B!t(B . ?#)  (?$B!u(B . ?&)  (?$B!v(B . ?*)  (?$B!w(B . ?@)
+		(?$B#0(B . ?0)  (?$B#1(B . ?1)  (?$B#2(B . ?2)  (?$B#3(B . ?3)  (?$B#4(B . ?4)
+		(?$B#5(B . ?5)  (?$B#6(B . ?6)  (?$B#7(B . ?7)  (?$B#8(B . ?8)  (?$B#9(B . ?9)
+		(?$B#A(B . ?A)  (?$B#B(B . ?B)  (?$B#C(B . ?C)  (?$B#D(B . ?D)  (?$B#E(B . ?E)
+		(?$B#F(B . ?F)  (?$B#G(B . ?G)  (?$B#H(B . ?H)  (?$B#I(B . ?I)  (?$B#J(B . ?J)
+		(?$B#K(B . ?K)  (?$B#L(B . ?L)  (?$B#M(B . ?M)  (?$B#N(B . ?N)  (?$B#O(B . ?O)
+		(?$B#P(B . ?P)  (?$B#Q(B . ?Q)  (?$B#R(B . ?R)  (?$B#S(B . ?S)  (?$B#T(B . ?T)
+		(?$B#U(B . ?U)  (?$B#V(B . ?V)  (?$B#W(B . ?W)  (?$B#X(B . ?X)  (?$B#Y(B . ?Y)
+		(?$B#Z(B . ?Z)
+		(?$B#a(B . ?a)  (?$B#b(B . ?b)  (?$B#c(B . ?c)  (?$B#d(B . ?d)  (?$B#e(B . ?e)
+		(?$B#f(B . ?f)  (?$B#g(B . ?g)  (?$B#h(B . ?h)  (?$B#i(B . ?i)  (?$B#j(B . ?j)
+		(?$B#k(B . ?k)  (?$B#l(B . ?l)  (?$B#m(B . ?m)  (?$B#n(B . ?n)  (?$B#o(B . ?o)
+		(?$B#p(B . ?p)  (?$B#q(B . ?q)  (?$B#r(B . ?r)  (?$B#s(B . ?s)  (?$B#t(B . ?t)
+		(?$B#u(B . ?u)  (?$B#v(B . ?v)  (?$B#w(B . ?w)  (?$B#x(B . ?x)  (?$B#y(B . ?y)
+		(?$B#z(B . ?z))
+	       (Chinese-GB
+		(?$A!!(B . ?\ ) (?$A#,(B . ?,)  (?$A#.(B . ?.)  (?$A!"(B . ?,)  (?$A!#(B . ?.)
+		(?$A#:(B . ?:)  (?$A#;(B . ?\;) (?$A#?(B . ??)  (?$A#!(B . ?!)
+		(?$A#`(B . ?`)  (?$A#^(B . ?^)  (?$A#_(B . ?_)  (?$A#~(B . ?~)
+		(?$A!*(B . ?-)
+		(?$A#/(B . ?/)  (?$A#\(B . ?\\) (?$A!+(B . ?~)  (?$A#|(B . ?|)
+		(?$A!.(B . ?`)  (?$A!/(B . ?')  (?$A!0(B . ?\") (?$A!1(B . ?\")
+		(?$A#((B . ?\() (?$A#)(B . ?\)) (?$A#[(B . ?[)  ( ?$A#](B . ?])
+		(?$A#{(B . ?{)  (?$A#}(B . ?})
+		(?$A#+(B . ?+)  (?$A#-(B . ?-)  (?$A#=(B . ?=)  (?$A#<(B . ?<)  (?$A#>(B . ?>)
+		(?$A#'(B . ?')  (?$A#"(B . ?\") (?$A#$(B . ?$)  (?$A#%(B . ?%)
+		(?$A##(B . ?#)  (?$A#&(B . ?&)  (?$A#*(B . ?*)  (?$A#@(B . ?@)
+		(?$A#0(B . ?0)  (?$A#1(B . ?1)  (?$A#2(B . ?2)  (?$A#3(B . ?3)  (?$A#4(B . ?4)
+		(?$A#5(B . ?5)  (?$A#6(B . ?6)  (?$A#7(B . ?7)  (?$A#8(B . ?8)  (?$A#9(B . ?9)
+		(?$A#A(B . ?A)  (?$A#B(B . ?B)  (?$A#C(B . ?C)  (?$A#D(B . ?D)  (?$A#E(B . ?E)
+		(?$A#F(B . ?F)  (?$A#G(B . ?G)  (?$A#H(B . ?H)  (?$A#I(B . ?I)  (?$A#J(B . ?J)
+		(?$A#K(B . ?K)  (?$A#L(B . ?L)  (?$A#M(B . ?M)  (?$A#N(B . ?N)  (?$A#O(B . ?O)
+		(?$A#P(B . ?P)  (?$A#Q(B . ?Q)  (?$A#R(B . ?R)  (?$A#S(B . ?S)  (?$A#T(B . ?T)
+		(?$A#U(B . ?U)  (?$A#V(B . ?V)  (?$A#W(B . ?W)  (?$A#X(B . ?X)  (?$A#Y(B . ?Y)
+		(?$A#Z(B . ?Z)
+		(?$A#a(B . ?a)  (?$A#b(B . ?b)  (?$A#c(B . ?c)  (?$A#d(B . ?d)  (?$A#e(B . ?e)
+		(?$A#f(B . ?f)  (?$A#g(B . ?g)  (?$A#h(B . ?h)  (?$A#i(B . ?i)  (?$A#j(B . ?j)
+		(?$A#k(B . ?k)  (?$A#l(B . ?l)  (?$A#m(B . ?m)  (?$A#n(B . ?n)  (?$A#o(B . ?o)
+		(?$A#p(B . ?p)  (?$A#q(B . ?q)  (?$A#r(B . ?r)  (?$A#s(B . ?s)  (?$A#t(B . ?t)
+		(?$A#u(B . ?u)  (?$A#v(B . ?v)  (?$A#w(B . ?w)  (?$A#x(B . ?x)  (?$A#y(B . ?y)
+		(?$A#z(B . ?z))
+	       (Chinese-CNS
+		(?$(G!!(B . ?\ ) (?$(G!"(B . ?,)  (?$(G!%(B . ?.)  (?$(G!#(B . ?,)  (?$(G!$(B . ?.)
+		(?$(G!((B . ?:)  (?$(G!'(B . ?\;) (?$(G!)(B . ??)  (?$(G!*(B . ?!)
+		(?$(G!k(B . ?')  (?$(G!j(B . ?`)  (?$(G!T(B . ?^)  (?$(G"%(B . ?_)  (?$(G"#(B . ?~)
+		(?$(G"@(B . ?-)
+		(?$(G"_(B . ?/)  (?$(G"`(B . ?\\) (?$(G"a(B . ?/)  (?$(G"b(B . ?\\)
+		(?$(G"D(B . ?~)  (?$(G"^(B . ?|)
+		(?$(G!d(B . ?`)  (?$(G!e(B . ?')
+		(?$(G!h(B . ?\") (?$(G!i(B . ?\") (?$(G!f(B . ?\") (?$(G!g(B . ?\")
+		(?$(G!>(B . ?\() (?$(G!?(B . ?\))
+		(?$(G!F(B . ?[)  (?$(G!G(B . ?])  (?$(G!b(B . ?[)  (?$(G!c(B . ?])
+		(?$(G!B(B . ?{)  (?$(G!C(B . ?})  (?$(G!`(B . ?{)  (?$(G!a(B . ?})
+		(?$(G!R(B . ?<)  (?$(G!S(B . ?>)
+		(?$(G"0(B . ?+)  (?$(G"1(B . ?-)  (?$(G"8(B . ?=)  (?$(G"6(B . ?<)  (?$(G"7(B . ?>)
+		(?$(G"c(B . ?$)  (?$(G"h(B . ?%)
+		(?$(G!l(B . ?#)  (?$(G!m(B . ?&)  (?$(G!n(B . ?*)  (?$(G"i(B . ?@)
+		(?$(G$!(B . ?0)  (?$(G$"(B . ?1)  (?$(G$#(B . ?2)  (?$(G$$(B . ?3)  (?$(G$%(B . ?4)
+		(?$(G$&(B . ?5)  (?$(G$'(B . ?6)  (?$(G$((B . ?7)  (?$(G$)(B . ?8)  (?$(G$*(B . ?9)
+		(?$(G$A(B . ?A)  (?$(G$B(B . ?B)  (?$(G$C(B . ?C)  (?$(G$D(B . ?D)  (?$(G$E(B . ?E)
+		(?$(G$F(B . ?F)  (?$(G$G(B . ?G)  (?$(G$H(B . ?H)  (?$(G$I(B . ?I)  (?$(G$J(B . ?J)
+		(?$(G$K(B . ?K)  (?$(G$L(B . ?L)  (?$(G$M(B . ?M)  (?$(G$N(B . ?N)  (?$(G$O(B . ?O)
+		(?$(G$P(B . ?P)  (?$(G$Q(B . ?Q)  (?$(G$R(B . ?R)  (?$(G$S(B . ?S)  (?$(G$T(B . ?T)
+		(?$(G$U(B . ?U)  (?$(G$V(B . ?V)  (?$(G$W(B . ?W)  (?$(G$X(B . ?X)  (?$(G$Y(B . ?Y)
+		(?$(G$Z(B . ?Z)
+		(?$(G$[(B . ?a)  (?$(G$\(B . ?b)  (?$(G$](B . ?c)  (?$(G$^(B . ?d)  (?$(G$_(B . ?e)
+		(?$(G$`(B . ?f)  (?$(G$a(B . ?g)  (?$(G$b(B . ?h)  (?$(G$c(B . ?i)  (?$(G$d(B . ?j)
+		(?$(G$e(B . ?k)  (?$(G$f(B . ?l)  (?$(G$g(B . ?m)  (?$(G$h(B . ?n)  (?$(G$i(B . ?o)
+		(?$(G$j(B . ?p)  (?$(G$k(B . ?q)  (?$(G$l(B . ?r)  (?$(G$m(B . ?s)  (?$(G$n(B . ?t)
+		(?$(G$o(B . ?u)  (?$(G$p(B . ?v)  (?$(G$q(B . ?w)  (?$(G$r(B . ?x)  (?$(G$s(B . ?y)
+		(?$(G$t(B . ?z))
+	       (Korean
+		(?$(C!!(B . ?\ ) (?$(C#,(B . ?,)  (?$(C#.(B . ?.)
+		(?$(C#:(B . ?:)  (?$(C#;(B . ?\;) (?$(C#?(B . ??)  (?$(C#!(B . ?!)
+		(?$(C!/(B . ?')  (?$(C!.(B . ?`)  (?$(C#^(B . ?^)  (?$(C#_(B . ?_)  (?$(C#~(B . ?~)
+		(?$(C!*(B . ?-)  (?$(C!)(B . ?-)
+		(?$(C#/(B . ?/)  (?$(C!,(B . ?\\) (?$(C!-(B . ?~)  (?$(C#|(B . ?|)
+		(?$(C!.(B . ?`)  (?$(C!/(B . ?')  (?$(C!0(B . ?\") (?$(C!1(B . ?\")
+		(?$(C#((B . ?\() (?$(C#)(B . ?\)) (?$(C#[(B . ?[)  (?$(C#](B . ?])
+		(?$(C#{(B . ?{)  (?$(C#}(B . ?})  (?$(C!4(B . ?<)  (?$(C!5(B . ?>)
+		(?$(C#+(B . ?+)  (?$(C#-(B . ?-)  (?$(C#=(B . ?=)  (?$(C#<(B . ?<)  (?$(C#>(B . ?>)
+		(?$(C#'(B . ?')  (?$(C#"(B . ?\") (?$(C#\(B . ?\\) (?$(C#$(B . ?$)  (?$(C#%(B . ?%)
+		(?$(C##(B . ?#)  (?$(C#&(B . ?&)  (?$(C#*(B . ?*)  (?$(C#@(B . ?@)
+		(?$(C#0(B . ?0)  (?$(C#1(B . ?1)  (?$(C#2(B . ?2)  (?$(C#3(B . ?3)  (?$(C#4(B . ?4)
+		(?$(C#5(B . ?5)  (?$(C#6(B . ?6)  (?$(C#7(B . ?7)  (?$(C#8(B . ?8)  (?$(C#9(B . ?9)
+		(?$(C#A(B . ?A)  (?$(C#B(B . ?B)  (?$(C#C(B . ?C)  (?$(C#D(B . ?D)  (?$(C#E(B . ?E)
+		(?$(C#F(B . ?F)  (?$(C#G(B . ?G)  (?$(C#H(B . ?H)  (?$(C#I(B . ?I)  (?$(C#J(B . ?J)
+		(?$(C#K(B . ?K)  (?$(C#L(B . ?L)  (?$(C#M(B . ?M)  (?$(C#N(B . ?N)  (?$(C#O(B . ?O)
+		(?$(C#P(B . ?P)  (?$(C#Q(B . ?Q)  (?$(C#R(B . ?R)  (?$(C#S(B . ?S)  (?$(C#T(B . ?T)
+		(?$(C#U(B . ?U)  (?$(C#V(B . ?V)  (?$(C#W(B . ?W)  (?$(C#X(B . ?X)  (?$(C#Y(B . ?Y)
+		(?$(C#Z(B . ?Z)
+		(?$(C#a(B . ?a)  (?$(C#b(B . ?b)  (?$(C#c(B . ?c)  (?$(C#d(B . ?d)  (?$(C#e(B . ?e)
+		(?$(C#f(B . ?f)  (?$(C#g(B . ?g)  (?$(C#h(B . ?h)  (?$(C#i(B . ?i)  (?$(C#j(B . ?j)
+		(?$(C#k(B . ?k)  (?$(C#l(B . ?l)  (?$(C#m(B . ?m)  (?$(C#n(B . ?n)  (?$(C#o(B . ?o)
+		(?$(C#p(B . ?p)  (?$(C#q(B . ?q)  (?$(C#r(B . ?r)  (?$(C#s(B . ?s)  (?$(C#t(B . ?t)
+		(?$(C#u(B . ?u)  (?$(C#v(B . ?v)  (?$(C#w(B . ?w)  (?$(C#x(B . ?x)  (?$(C#y(B . ?y)
+		(?$(C#z(B . ?z))))
+      (hash (make-vector 100 nil))
+      lang pair)
+  (while table
+    (setq lang (caar table)
+	  pair (cdar table)
+	  table (cdr table))
+    (while pair
+      (set (intern (char-to-string (caar pair)) its-full-half-table)
+	   (cdar pair))
+      (set (intern (concat (symbol-name lang) (char-to-string (cdar pair)))
+		   its-half-full-table)
+	   (caar pair))
+      (setq pair (cdr pair)))
+    hash))
 
-;;; its-zenkaku : zenkaku-region for input-buffer
-(defun its-zenkaku ()
+;;; its-half-width : half-width-region for input-buffer
+(defun its-half-width ()
   (interactive)
-  (let ((inhibit-read-only t))
-    (its-input-end)
-    (its-set-part-1 (point) (its-search-end))
-    (its-convert 'japanese-zenkaku (its-search-beginning) (point))
-    (its-put-cursor t)))
+  (its-convert
+   (lambda (str lang)
+     (concat (mapcar (lambda (c)
+		       (or (symbol-value (intern-soft (char-to-string c)
+						      its-full-half-table))
+			   c))
+		     (string-to-sequence str 'list))))))
 
-(defun its-convert (func start end)
-  (let* ((goto-start (eq (point) start))
-	 (old-str (buffer-substring start end))
-	 (new-str "")
-	 (len (length old-str))
-	 (p 0)
-	 old new syl q)
-    (while (< p len)
-      (setq q (next-single-property-change p 'its-syl old-str len)
-	    old (substring old-str p q)
-	    new (copy-sequence old))
-      (set-text-properties 0 (- q p) nil new)
-      (setq new (funcall func new))
-      (if (equal new old)
-	  (setq new-str (concat new-str old))
-	(setq syl (cons (copy-sequence new) (copy-sequence new)))
-	(set-text-properties 0 (length new) (text-properties-at 0 old) new)
-	(put-text-property 0 (length new) 'its-syl syl new)
-	(setq new-str (concat new-str new)))
-      (setq p q))
-    (delete-region start end)
-    (insert new-str)
-    (if goto-start
-	(goto-char start))))
+;;; its-full-width : full-width-region for input-buffer
+(defun its-full-width ()
+  (interactive)
+  (its-convert
+   (lambda (str lang)
+     (if (egg-chinese-syllable str 0)
+	 (copy-sequence str)
+       (concat (mapcar (lambda (c)
+			 (or (symbol-value
+			      (intern-soft (concat (symbol-name lang)
+						   (char-to-string c))
+					   its-half-full-table))
+			     c))
+		       (string-to-sequence str 'list)))))))
+
+(defun its-convert (func)
+  (let ((inhibit-read-only t))
+    (unwind-protect
+	(progn
+	  (its-input-end)
+	  (let* ((start (its-search-beginning))
+		 (end (its-search-end))
+		 (old-str (buffer-substring start end))
+		 (len (length old-str))
+		 (p 0)
+		 (new-str ""))
+	    (put-text-property 0 len 'intangible 'its-part-1 old-str)
+	    (while (< p len)
+	      (let* ((prop (text-properties-at p old-str))
+		     (cmp (memq 'composition prop))
+		     (old (its-get-output (plist-get prop 'its-syl)))
+		     (new (funcall func old (plist-get prop 'egg-lang)))
+		     (new-len (length new))
+		     syl)
+		(unless (equal new old)
+		  (when cmp
+		    (if (eq prop cmp)
+			(setq prop (cddr prop))
+		      (setcdr (nthcdr (- (length prop) (length cmp) 1) prop)
+			      (cddr cmp))))
+		  (setq syl (copy-sequence new))
+		  (plist-put prop 'its-syl (cons syl syl)))
+		(add-text-properties 0 new-len prop new)
+		(setq new-str (concat new-str new)
+		      p (+ p (length old)))))
+	    (delete-region start end)
+	    (insert new-str)))
+      (its-put-cursor t))))
 
 (defun its-mode ()
   "\\{its-mode-map}"
Only in .: jisx0213.el
diff -u -3 ../tamago-4.0.6/leim-list.el ./leim-list.el
--- ../tamago-4.0.6/leim-list.el	Tue Jan 11 22:47:31 2000
+++ ./leim-list.el
@@ -32,8 +32,10 @@
 ;;; Code:
 
 (when site-run-file
-  (autoload 'egg-activate-wnn "egg/wnn" "Activate Wnn backend of Tamagotchy." t)
-  (autoload 'egg-activate-sj3 "egg/sj3" "Activate SJ3 backend of Tamagotchy." t)
+  (autoload 'egg-activate-wnn "egg/wnn" "Activate Wnn backend of Tamago 4." t)
+  (autoload 'egg-activate-sj3 "egg/sj3" "Activate SJ3 backend of Tamago 4." t)
+  (autoload 'egg-activate-canna "egg/canna"
+    "Activate CANNA backend of Tamago 4." t)
 
   (register-input-method
    "japanese-egg-wnn" "Japanese" 'egg-activate-wnn
@@ -46,6 +48,11 @@
    'its-select-hiragana)
 
   (register-input-method
+   "japanese-egg-canna" "Japanese" 'egg-activate-canna
+   "$B$"(B.."  "Romaji -> Hiragana -> Kanji&Kana"
+   'its-select-hiragana)
+
+  (register-input-method
    "chinese-gb-egg-wnn-py" "Chinese-GB" 'egg-activate-wnn
    "$AF4(BG"  "Pinyin -> Simplified Hanzi"
    'its-select-pinyin-cn)
@@ -100,6 +107,9 @@
 (defgroup sj3 nil ""
   :group 'egg :load "egg/sj3")
 
+(defgroup canna nil ""
+  :group 'egg :load "egg/canna")
+
 (defgroup its nil "" 
   :group 'egg :load "its")
 
@@ -119,4 +129,4 @@
   (message "Finished loading %s \n   and load others..." load-file-name)
   (load-leim-list-except-this)
 
-  )
+  )
diff -u -3 ../tamago-4.0.6/menudiag.el ./menudiag.el
--- ../tamago-4.0.6/menudiag.el	Tue Jan  4 15:53:49 2000
+++ ./menudiag.el
@@ -50,7 +50,7 @@
 ;;
 
 (defgroup menudiag nil
-  "Input Translation System of Tamagotchy"
+  "Input Translation System of Tamago 4."
   :group 'egg)
 
 (defcustom menudiag-select-without-return nil
@@ -72,26 +72,34 @@
     (while (<= ch ?Z)
       (define-key map (char-to-string ch) 'menudiag-goto-item)
       (setq ch (1+ ch)))
-    (define-key map "\C-a" 'menudiag-beginning-of-line)
-    (define-key map "\C-e" 'menudiag-end-of-line)
-    (define-key map "\M-<" 'menudiag-beginning-of-items)
-    (define-key map "\M->" 'menudiag-end-of-items)
-    (define-key map "\C-f" 'menudiag-forward-item)
-    (define-key map "\C-b" 'menudiag-backward-item)
-    (define-key map "\C-n" 'menudiag-next-line)
-    (define-key map "\C-p" 'menudiag-previous-line)
-    (define-key map "\C-]" 'menudiag-exit)
-    (define-key map "\C-g" 'menudiag-exit-one-level)
-    (define-key map "\C-l" 'menudiag-redraw)
-    (define-key map "\C-m" 'menudiag-select-this-item)
-    (define-key map "?"    'menudiag-list-other-window)
+    (setq ch ?\C-0)
+    (while (<= ch ?\C-9)
+      (define-key map (vector ch) 'digit-argument)
+      (setq ch (1+ ch)))
+    (define-key map [?\C--]  'negative-argument)
+    (define-key map [?\C-u]  'universal-argument)
+    (define-key map " "      'menudiag-forward-item)
+    (define-key map "\C-a"   'menudiag-beginning-of-line)
+    (define-key map "\C-e"   'menudiag-end-of-line)
+    (define-key map "\M-<"   'menudiag-beginning-of-items)
+    (define-key map "\M->"   'menudiag-end-of-items)
+    (define-key map "\C-f"   'menudiag-forward-item)
+    (define-key map "\C-b"   'menudiag-backward-item)
+    (define-key map "\C-n"   'menudiag-next-line)
+    (define-key map "\C-p"   'menudiag-previous-line)
+    (define-key map "\C-]"   'menudiag-exit)
+    (define-key map "\C-g"   'menudiag-exit-one-level)
+    (define-key map "\C-l"   'menudiag-redraw)
+    (define-key map "\C-m"   'menudiag-select-this-item)
+    (define-key map "\M-v"   'menudiag-list-other-window)
+    (define-key map "?"      'menudiag-list-other-window)
     (define-key map [return] 'menudiag-select-this-item)
-    (define-key map [left] 'menudiag-backward-item)
-    (define-key map [right] 'menudiag-forward-item)
-    (define-key map [up] 'menudiag-previous-line)
-    (define-key map [down] 'menudiag-next-line)
-    (define-key map [menudiag-continuation] 'menudiag-follow-continuation)
-    (define-key map [t] 'undefined)
+    (define-key map [left]   'menudiag-backward-item)
+    (define-key map [right]  'menudiag-forward-item)
+    (define-key map [up]     'menudiag-previous-line)
+    (define-key map [down]   'menudiag-next-line)
+    (define-key map [exit]   'menudiag-exit)
+    (define-key map [t]      'undefined)
     map)
   "Keymap for MENU.")
 
@@ -111,8 +119,6 @@
 (defsubst menudiag-item-width (item)
   (+ 4 (string-width (menudiag-item-string item))))
 
-(defvar menudiag-window-conf nil)
-
 (defun menudiag-make-selection-list (item-list line-width)
   (let ((l nil)
 	(line nil)
@@ -135,66 +141,121 @@
 	(reverse (cons (reverse line) l))
       (reverse l))))
 
+(defvar menudiag-show-all nil)
+(make-variable-buffer-local 'menudiag-show-all)
+
+(defvar menudiag-continuation nil)
+(make-variable-buffer-local 'menudiag-continuation)
+
+(defvar menudiag-return-contin nil)
+(make-variable-buffer-local 'menudiag-return-contin)
+
+(defvar menudiag-value nil)
+(make-variable-buffer-local 'menudiag-value)
+
+(defvar menudiag-done nil)
+(make-variable-buffer-local 'menudiag-done)
+
 ;; Entry function
-(defun menudiag-select (menu &optional menudiag-continuation return-contin)
-  (let ((enable-recursive-minibuffers t)
-	value done)
-    (setq menudiag-window-conf nil)
-    (if menudiag-continuation
-	(setq unread-command-events (cons 'menudiag-continuation
-					  unread-command-events)))
-    (if (not return-contin)
-	(setq value t))
-    (menudiag-select-internal menu)
-    (if (eq done t)
-	value
+(defun menudiag-select (menu &optional list-all continuation return-contin)
+  (let ((enable-recursive-minibuffers t))
+    (setq menudiag-return-contin return-contin)
+    (menudiag-select-internal menu list-all continuation)
+    (if (eq menudiag-done t)
+	menudiag-value
       (signal 'quit ""))))
 
-;; Entry function
-(defun menudiag-get-value (continuation)
-  (menudiag-item-value (nth (1- (length continuation)) continuation)))
+(defvar menudiag-line nil)
+(make-variable-buffer-local 'menudiag-line)
+
+(defvar menudiag-linepos 0)
+(make-variable-buffer-local 'menudiag-linepos)
+
+(defvar menudiag-pos-in-line 0)
+(make-variable-buffer-local 'menudiag-pos-in-line)
 
 (defun menudiag-follow-continuation ()
-  (interactive)
-  (let ((item (car menudiag-continuation)))
-    (setq menudiag-continuation (cdr menudiag-continuation))
-    (if menudiag-continuation
-	(setq unread-command-events (cons 'menudiag-continuation
-					  unread-command-events)))
-    (if (eq item 'menudiag-list-all)
-	(menudiag-list-other-window)
-      (let ((in-loop t))
-	(while in-loop
-	  (if (eq item (nth pos-in-line line))
-	      (setq in-loop nil)
-	    (menudiag-forward-item)
-	    (if (and (= linepos 0) (= pos-in-line 0))
-		(error "no such item: %s" (menudiag-item-string item))))))
-      (let ((v (menudiag-item-value item)))
-	(if (menudiag-menu-p v)
-	    (unwind-protect
-		(progn
-		  (menudiag-select-internal v)
-		  (menudiag-redraw))
-	      (if (consp value)
-		  (setq value (cons item value)))
-	      (if done (menudiag-exit-minibuffer))))))))
-
-(defun menudiag-select-internal (menu)
-  (let* ((minibuf-prompt (nth 1 menu))
-	 (current-items (nth 2 menu))
-	 (selection-list
-	  (menudiag-make-selection-list current-items
-					(- (window-width (minibuffer-window))
-					   (string-width minibuf-prompt))))
-	 (line (car selection-list))
-	 (minibuf-contents
-	  (menudiag-make-menu-formatted-string line)))
-    (let ((linepos 0)
-	  (pos-in-line 0))
-      (read-from-minibuffer minibuf-prompt
-			    (cons minibuf-contents 3)
-			    menudiag-mode-map))))
+  (let* ((item (car menudiag-continuation))
+	 (value (menudiag-item-value item))
+	 (pos (menudiag-search-item item)))
+    (unless pos
+      (error "no such item: %s" (menudiag-item-string item)))
+    (menudiag-goto-line (car pos))
+    (menudiag-goto-item-internal (cdr pos))
+    (when (menudiag-menu-p value)
+      (menudiag-select-internal value
+				menudiag-show-all
+				(cdr menudiag-continuation))
+      (menudiag-redraw)
+      (when menudiag-done
+	(when menudiag-return-contin
+	  (setq menudiag-value (cons item menudiag-value)))
+	(setq unread-command-events (cons 'exit unread-command-events))))))
+
+(defvar menudiag-minibuffer-list nil)
+(defvar menudiag-variable-alist nil)
+
+(defmacro menudiag-send-variables (&rest args)
+  `(setq menudiag-variable-alist
+	 (list ,@(mapcar (lambda (var) `(cons ',var ,var)) args))))
+
+(defmacro menudiag-send-variables-with-value (&rest args)
+  `(setq menudiag-variable-alist
+	 ,(let ((alist (list 'list)))
+	    (while args
+	      (nconc alist `((cons ',(car args) ,(cadr args))))
+	      (setq args (cddr args)))
+	    alist)))
+
+(defun menudiag-receive-variables ()
+  (while menudiag-variable-alist
+    (set (caar menudiag-variable-alist) (cdar menudiag-variable-alist))
+    (setq menudiag-variable-alist (cdr menudiag-variable-alist))))
+
+(defvar menudiag-minibuf-prompt nil)
+(make-variable-buffer-local 'menudiag-minibuf-prompt)
+
+(defvar menudiag-current-items nil)
+(make-variable-buffer-local 'menudiag-current-items)
+
+(defvar menudiag-selection-list nil)
+(make-variable-buffer-local 'menudiag-selection-list)
+
+(defun menudiag-minibuffer-hook ()
+  (interactive)
+  (remove-hook 'minibuffer-setup-hook 'menudiag-minibuffer-hook)
+  (setq menudiag-minibuffer-list (cons (current-buffer)
+				       menudiag-minibuffer-list))
+  (buffer-disable-undo)
+  (menudiag-receive-variables)
+  (menudiag-beginning-of-items)
+  (when menudiag-continuation
+    (menudiag-follow-continuation))
+  (when (and menudiag-show-all (null menudiag-done))
+    (menudiag-list-other-window)))
+
+(defun menudiag-select-internal (menu all &optional continuation)
+  (menudiag-send-variables-with-value
+   menudiag-value          menudiag-value
+   menudiag-continuation   continuation
+   menudiag-return-contin  menudiag-return-contin
+   menudiag-show-all       all
+   menudiag-minibuf-prompt (cadr menu)
+   menudiag-current-items  (car (cddr menu))
+   menudiag-selection-list (menudiag-make-selection-list 
+			    (car (cddr menu))
+			    (- (window-width (minibuffer-window))
+			       (string-width (cadr menu)))))
+  (add-hook 'minibuffer-setup-hook 'menudiag-minibuffer-hook)
+  (unwind-protect
+      (progn
+	(read-from-minibuffer "" "" menudiag-mode-map)
+	(menudiag-receive-variables))
+    (setq menudiag-minibuffer-list (cdr menudiag-minibuffer-list))
+    (remove-hook 'minibuffer-setup-hook 'menudiag-minibuffer-hook)
+    ;; for egg's point-enterd/left hooks
+    (save-excursion
+      (goto-char (point-min)))))
 
 (defun menudiag-make-menu-formatted-string (item-list)
   (let ((i -1))
@@ -217,7 +278,7 @@
     char))
 
 ;; Character --> ITEM No
-(defun menudiag-char-to-item-num (char)
+(defun menudiag-char-to-item-num (ch)
   (let ((num))
     (cond ((and (<= ?0 ch) (<= ch ?9))
            (setq num (- ch ?0)))
@@ -228,44 +289,52 @@
           (t (setq num 1000)))
     num))
 
+(defun menudiag-check-current-menu ()
+  (or (eq (current-buffer) (car menudiag-minibuffer-list))
+      (error "menudiag: not current menu")))
+
 (defun menudiag-goto-item ()
   (interactive)
+  (menudiag-check-current-menu)
   (let ((ch last-command-char)
 	(n 0))
     (setq n (menudiag-char-to-item-num ch))
-    (if (>= n (length line))
+    (if (>= n (length menudiag-line))
 	(error "No such item")
       (menudiag-goto-item-internal n)
       (if menudiag-select-without-return
 	  (menudiag-select-this-item)))))
 
 (defun menudiag-goto-item-internal (n)
-  (let ((old-pos-in-line pos-in-line)
-	(p 3)
+  (let ((p (+ (length menudiag-minibuf-prompt) 3))
 	(i 0))
-    (setq pos-in-line n)
-    (while (< i pos-in-line)
-      (setq p (+ p (length (menudiag-item-string (nth i line))) 4))
+    (setq menudiag-pos-in-line n)
+    (while (< i menudiag-pos-in-line)
+      (setq p (+ p (length (menudiag-item-string (nth i menudiag-line))) 4))
       (setq i (1+ i)))
     (goto-char p)))
 
 (defun menudiag-beginning-of-items ()
   (interactive)
+  (menudiag-check-current-menu)
   (menudiag-goto-line 0)
   (menudiag-beginning-of-line))
 
 (defun menudiag-end-of-items ()
   (interactive)
-  (menudiag-goto-line (1- (length selection-list)))
+  (menudiag-check-current-menu)
+  (menudiag-goto-line (1- (length menudiag-selection-list)))
   (menudiag-end-of-line))
 
 (defun menudiag-beginning-of-line ()
   (interactive)
+  (menudiag-check-current-menu)
   (menudiag-goto-item-internal 0))
 
 (defun menudiag-end-of-line ()
   (interactive)
-  (menudiag-goto-item-internal (1- (length line))))
+  (menudiag-check-current-menu)
+  (menudiag-goto-item-internal (1- (length menudiag-line))))
 
 ;; Should retain compatibility.  Must.
 ;;
@@ -296,127 +365,166 @@
 ;;    (insert (menudiag-make-menu-formatted-string line))))
 ;;
 
-(defun menudiag-forward-item ()
-  (interactive)
-  (if (< pos-in-line (1- (length line)))
-      (menudiag-goto-item-internal (1+ pos-in-line))
-    (if (>= linepos (1- (length selection-list)))
-	(menudiag-goto-line 0)
-      (menudiag-goto-line (1+ linepos)))
-    (menudiag-beginning-of-line)))
-
-(defun menudiag-backward-item ()
-  (interactive)
-  (if (< 0 pos-in-line)
-      (menudiag-goto-item-internal (1- pos-in-line))
-    (if (< linepos 1)
-        (menudiag-goto-line (1- (length selection-list)))
-      (menudiag-goto-line (1- linepos)))
-    (menudiag-end-of-line)))
+(defun menudiag-forward-item (n)
+  (interactive "p")
+  (menudiag-forward-item-internal n))
+
+(defun menudiag-backward-item (n)
+  (interactive "p")
+  (menudiag-forward-item-internal (- n)))
+
+(defun menudiag-forward-item-internal (n)
+  (menudiag-check-current-menu)
+  (setq n (+ n menudiag-pos-in-line))
+  (while (< n 0)
+    (menudiag-goto-line (1- menudiag-linepos))
+    (setq n (+ n (length menudiag-line))))
+  (while (>= n (length menudiag-line))
+    (setq n (- n (length menudiag-line)))
+    (menudiag-goto-line (1+ menudiag-linepos)))
+  (menudiag-goto-item-internal n))
 
 (defun menudiag-goto-line (n)
-  (cond
-   ((>= n (length selection-list))
-    (setq n 0))
-   ((< n 0)
-    (setq n (1- (length selection-list)))))
-  (setq line (nth n selection-list)
-        linepos n)
-  (delete-region (point-min) (point-max))
-  (insert (menudiag-make-menu-formatted-string line)))
-
-(defun menudiag-next-line ()
-  (interactive)
-  (menudiag-goto-line (1+ linepos))
-  (if (< pos-in-line (length line))
-      (menudiag-goto-item-internal pos-in-line)
-    (menudiag-end-of-line)))
-
-(defun menudiag-previous-line ()
-  (interactive)
-  (menudiag-goto-line (1- linepos))
-  (if (< pos-in-line (length line))
-      (menudiag-goto-item-internal pos-in-line)
+  (let ((len (length menudiag-selection-list)))
+    (when (< n 0)
+      (setq n (+ (% n len) len)))
+    (when (>= n len)
+      (setq n (% n len)))
+    (setq menudiag-line (nth n menudiag-selection-list)
+	  menudiag-linepos n)
+    (let ((inhibit-read-only t))
+      (erase-buffer)
+      (insert menudiag-minibuf-prompt
+	      (menudiag-make-menu-formatted-string menudiag-line))
+      (set-text-properties (point-min) (point-max) '(read-only t)))))
+
+(defun menudiag-next-line (n)
+  (interactive "p")
+  (menudiag-next-line-internal n))
+
+(defun menudiag-previous-line (n)
+  (interactive "p")
+  (menudiag-next-line-internal (- n)))
+
+(defun menudiag-next-line-internal (n)
+  (menudiag-check-current-menu)
+  (menudiag-goto-line (+ menudiag-linepos n))
+  (if (< menudiag-pos-in-line (length menudiag-line))
+      (menudiag-goto-item-internal menudiag-pos-in-line)
     (menudiag-end-of-line)))
 
 (defun menudiag-redraw ()
   (interactive)
-  (menudiag-goto-line linepos)
-  (menudiag-goto-item-internal pos-in-line))
+  (menudiag-check-current-menu)
+  (menudiag-goto-line menudiag-linepos)
+  (menudiag-goto-item-internal menudiag-pos-in-line))
 
 (defun menudiag-exit-one-level ()
   (interactive)
+  (menudiag-check-current-menu)
   (menudiag-exit-minibuffer))
 
 (defun menudiag-exit ()
   (interactive)
-  (setq done 'quit)
+  (menudiag-check-current-menu)
+  (unless menudiag-done
+    (setq menudiag-done 'quit))
   (menudiag-exit-minibuffer))
 
-(defun menudiag-select-this-item ()
+(defun menudiag-select-this-item (&optional all)
   (interactive)
-  (let* ((item (nth pos-in-line line))
+  (menudiag-check-current-menu)
+  (let* ((item (nth menudiag-pos-in-line menudiag-line))
 	 (v (menudiag-item-value item)))
     (if (menudiag-menu-p v)
-	(unwind-protect
-	    (progn
-	      (menudiag-restore-window)
-	      (menudiag-select-internal v)
-	      (menudiag-redraw))
-	  (if (consp value)
-	      (setq value (cons item value)))
-	  (if done (menudiag-exit-minibuffer)))
-      (if (eq value t)
-	  (setq value (menudiag-item-value item))
-	(setq value (cons item nil)))
-      (setq done t)
+	(progn
+	  (menudiag-restore-window)
+	  (menudiag-select-internal v all)
+	  (menudiag-redraw)
+	  (cond (menudiag-done
+		 (when menudiag-return-contin
+		   (setq menudiag-value (cons item menudiag-value)))
+		 (menudiag-exit-minibuffer))
+		(all
+		 (menudiag-list-other-window))))
+      (setq menudiag-value (if menudiag-return-contin
+			       (list item)
+			     (menudiag-item-value item))
+	    menudiag-done t)
       (menudiag-exit-minibuffer))))
+
+(defun menudiag-search-item (item)
+  (let ((selection-list menudiag-selection-list)
+	(line 0)
+	rest)
+    (while (and selection-list
+		(null (setq rest (memq item (car selection-list)))))
+      (setq selection-list (cdr selection-list)
+	    line (1+ line)))
+    (and selection-list
+	 (cons line (- (length (car selection-list)) (length rest))))))
 
 (defconst menudiag-selection-map
-  (let ((map (make-sparse-keymap)))
-    (define-key map [right]   'next-completion)
-    (define-key map [left]    'previous-completion)
-    (define-key map "\r"      'menudiag-choose-item)
-    (define-key map [mouse-2] 'menudiag-mouse-choose-item)
-    map))
+  (let ((map (make-sparse-keymap))
+	(ch ?0))
+    (while (<= ch ?9)
+      (define-key map (char-to-string ch) 'menudiag-selection-goto)
+      (setq ch (1+ ch)))
+    (define-key map "q"            'menudiag-retun-to-minibuf)
+    (define-key map "\C-b"         'previous-completion)
+    (define-key map "\M-b"         'previous-completion)
+    (define-key map "\C-f"         'next-completion)
+    (define-key map "\M-f"         'next-completion)
+    (define-key map " "            'next-completion)
+    (define-key map "\C-g"         'menudiag-selection-exit-one-level)
+    (define-key map "\C-m"         'menudiag-choose-item)
+    (define-key map "\C-]"         'menudiag-selection-exit)
+    (define-key map "\177"         'menudiag-selection-goto-delete)
+    (define-key map [delete]       'menudiag-selection-goto-delete)
+    (define-key map [backspace]    'menudiag-selection-goto-delete)
+    (define-key map [right]        'next-completion)
+    (define-key map [left]         'previous-completion)
+    (define-key map [return]       'menudiag-choose-item)
+    (define-key map [mouse-2]      'menudiag-mouse-choose-item)
+    map)
+  "keymap for menu selection mode")
+
+(defvar menudiag-window-conf nil)
+(make-variable-buffer-local 'menudiag-window-conf)
 
 (defvar menudiag-selection-buffer nil)
 (make-variable-buffer-local 'menudiag-selection-buffer)
-(put 'menudiag-selection-buffer 'permanent-local t)
 
 (defvar menudiag-selection-main-buffer nil)
 (make-variable-buffer-local 'menudiag-selection-main-buffer)
-(put 'menudiag-selection-main-buffer 'permanent-local t)
 
 (defun menudiag-selection-mode ()
-  (interactive)
   (kill-all-local-variables)
   (make-local-variable 'inhibit-read-only)
   (setq buffer-read-only t
 	inhibit-read-only nil)
+  (make-local-hook 'post-command-hook)
+  (add-hook 'post-command-hook 'menudiag-selection-align-to-item nil t)
   (use-local-map menudiag-selection-map)
   (setq mode-name "Menudiag Selection")
   (setq major-mode 'menudiag-selection-mode))
 
-(defun menudiag-max-item-width (item-list)
-  (let ((max 0))
-    (while item-list
-      (setq max (max max (menudiag-item-width (car item-list)))
-	    item-list (cdr item-list)))
-    max))
+(defun menudiag-max-item-width (items)
+  (apply 'max (mapcar 'menudiag-item-width items)))
 
 (defun menudiag-buffer-show-function ()
-  (let* ((items current-items)
-	 (digits (length (concat (length items))))
-	 (columns (max 1 (/ (window-width (minibuffer-window))
+  (menudiag-receive-variables)
+  (let* ((items menudiag-current-items)
+	 (digits (length (number-to-string (length items))))
+	 (form (concat "%" (number-to-string digits) "d. %s"))
+	 (columns (max 1 (/ (window-width (selected-window))
 			    (+ digits (menudiag-max-item-width items)))))
-	 (width (/ (window-width (minibuffer-window)) columns))
-	 (col 0) (n 0) str)
+	 (width (/ (window-width (selected-window)) columns))
+	 (col 0) (n 0) str p)
     (insert " ")
     (while items
       (setq p (point)
-	    str (format (concat "%" digits "d. %s")
-			n (menudiag-item-string (car items))))
+	    str (format form n (menudiag-item-string (car items))))
       (insert str)
       (set-text-properties p (point) '(mouse-face highlight))
       (setq col (1+ col)
@@ -433,75 +541,156 @@
 
 (defun menudiag-buffer-name (prompt)
   (let ((len (1- (length prompt))))
-    (if (= (aref prompt len) ?:) (substring prompt 0 len) prompt)))
+    (generate-new-buffer-name
+     (if (= (aref prompt len) ?:) (substring prompt 0 len) prompt))))
 
 (defun menudiag-list-other-window ()
   (interactive)
-  (let ((temp-buffer-show-hook 'menudiag-buffer-show-function)
-	(main-buf (current-buffer)))
-    (setq menudiag-window-conf (current-window-configuration))
-    (with-output-to-temp-buffer (menudiag-buffer-name minibuf-prompt)
-      (setq menudiag-selection-buffer standard-output))
-    (set-buffer menudiag-selection-buffer)
-    (setq menudiag-selection-main-buffer main-buf)))
+  (menudiag-check-current-menu)
+  (let ((window (and menudiag-selection-buffer
+		     (get-buffer-window menudiag-selection-buffer))))
+    (if window
+	(select-window window)
+      (let ((temp-buffer-show-hook 'menudiag-buffer-show-function)
+	    (main-buf (current-buffer))
+	    (selection-list menudiag-selection-list)
+	    (linepos menudiag-linepos)
+	    (n (1+ menudiag-pos-in-line)))
+	(setq menudiag-window-conf (current-window-configuration))
+	(menudiag-send-variables menudiag-current-items)
+	(with-output-to-temp-buffer
+	    (menudiag-buffer-name menudiag-minibuf-prompt)
+	  (setq menudiag-selection-buffer standard-output))
+	(switch-to-buffer-other-window menudiag-selection-buffer)
+	(setq menudiag-selection-main-buffer main-buf
+	      menudiag-selection-list selection-list)
+	(while (> linepos 0)
+	  (setq linepos (1- linepos)
+		n (+ n (length (car selection-list)))
+		selection-list (cdr selection-list)))
+	(next-completion n)))))
+
+(defun menudiag-check-current-menu-list ()
+  (or (eq menudiag-selection-main-buffer (car menudiag-minibuffer-list))
+      (error "menudiag: not current menu list")))
 
 (defun menudiag-choose-item ()
   (interactive)
-  (let ((org-buf menudiag-selection-main-buffer)
-	(sel-buf (current-buffer))
-	(item-list selection-list)
-	(l 0)
-	tmp-buf n)
-    (with-temp-buffer
-      (setq tmp-buf (current-buffer))
-      (set-buffer sel-buf)
-      (setq completion-reference-buffer tmp-buf)
-      (choose-completion)
-      (set-buffer tmp-buf)
-      (setq n (string-to-int (buffer-string))))
-    (pop-to-buffer org-buf)
-    (while (and item-list (>= (- n (length (car item-list))) 0))
-      (setq l (1+ l)
-	    n (- n (length (car item-list)))
-	    item-list (cdr item-list)))
-    (menudiag-goto-line l)
-    (menudiag-goto-item-internal n)
-    (menudiag-select-this-item)))
+  (menudiag-choose-item-internal nil))
 
 (defun menudiag-mouse-choose-item (event)
   (interactive "e")
-  (set-buffer (window-buffer (car (nth 1 event))))
+  (set-buffer (window-buffer (caadr event)))
+  (menudiag-choose-item-internal event))
+
+(defun menudiag-choose-item-internal (event)
+  (menudiag-check-current-menu-list)
   (let ((org-buf menudiag-selection-main-buffer)
 	(sel-buf (current-buffer))
-	(item-list selection-list)
+	(item-list menudiag-selection-list)
 	(l 0)
 	tmp-buf n)
     (with-temp-buffer
       (setq tmp-buf (current-buffer))
       (set-buffer sel-buf)
       (setq completion-reference-buffer tmp-buf)
-      (mouse-choose-completion event)
+      (if event
+	  (mouse-choose-completion event)
+	(choose-completion))
       (set-buffer tmp-buf)
       (setq n (string-to-int (buffer-string))))
     (pop-to-buffer org-buf)
-    (while (and item-list (>= (- n (length (car item-list))) 0))
+    (while (and item-list (>= n (length (car item-list))))
       (setq l (1+ l)
 	    n (- n (length (car item-list)))
 	    item-list (cdr item-list)))
     (menudiag-goto-line l)
     (menudiag-goto-item-internal n)
-    (menudiag-select-this-item)))
+    (menudiag-select-this-item t)))
+
+(defvar menudiag-goto-number-list nil)
+(make-variable-buffer-local 'menudiag-goto-number-list)
+
+(defvar menudiag-original-point nil)
+(make-variable-buffer-local' menudiag-original-point)
+
+(defun menudiag-selection-goto ()
+  (interactive)
+  (unless (eq last-command 'menudiag-selection-goto)
+    (setq menudiag-goto-number-list nil
+	  menudiag-original-point (point)))
+  (setq menudiag-goto-number-list (cons (- last-command-char ?0)
+					menudiag-goto-number-list))
+  (menudiag-selection-goto-internal))
+
+(defun menudiag-selection-goto-internal ()
+  (let* ((list menudiag-goto-number-list)
+	 (n (menudiag-selection-item-number list))
+	 (len (save-excursion
+		(set-buffer menudiag-selection-main-buffer)
+		(length menudiag-current-items))))
+    (setq this-command 'menudiag-selection-goto)
+    (if (>= n len)
+	(progn
+	  (ding)
+	  (setq menudiag-goto-number-list (cdr list)))
+    (goto-char (point-min))
+    (next-completion (1+ n)))))
+
+(defun menudiag-selection-item-number (list)
+  (let ((n 0)
+	(exp 1))
+    (while list
+      (setq n (+ (* (car list) exp) n)
+	    exp (* 10 exp)
+	    list (cdr list)))
+    n))
+
+(defun menudiag-selection-goto-delete (n)
+  (interactive "p")
+  (if (null (eq last-command 'menudiag-selection-goto))
+      (ding)
+    (setq menudiag-goto-number-list (nthcdr n menudiag-goto-number-list))
+    (if (null menudiag-goto-number-list)
+	(goto-char menudiag-original-point)
+      (menudiag-selection-goto-internal))))
+
+(defun menudiag-selection-align-to-item ()
+  (cond ((bolp)
+	 (next-completion 1))
+	((get-text-property (1- (point)) 'mouse-face)
+	 (goto-char (previous-single-property-change (point) 'mouse-face)))))
 
 (defun menudiag-restore-window ()
-  (if menudiag-window-conf
-      (progn
-	(set-window-configuration menudiag-window-conf)
-	(setq menudiag-window-conf nil)
-	(kill-buffer menudiag-selection-buffer))))
+  (when menudiag-window-conf
+    (set-window-configuration menudiag-window-conf)
+    (kill-buffer menudiag-selection-buffer)))
 
 (defun menudiag-exit-minibuffer ()
-  (and menudiag-window-conf (menudiag-restore-window))
+  (menudiag-restore-window)
+  (menudiag-send-variables menudiag-done menudiag-value)
+  (buffer-enable-undo)
   (exit-minibuffer))
+
+(defun menudiag-retun-to-minibuf ()
+  (interactive)
+  (menudiag-check-current-menu-list)
+  (unless (minibuffer-window-active-p (minibuffer-window))
+    (set-minibuffer-window (minibuffer-window)))
+  (let ((window (get-buffer-window menudiag-selection-main-buffer)))
+    (if window
+	(select-window window)
+      (error "menudiag: cannot find minibuffer"))))
+
+(defun menudiag-selection-exit-one-level ()
+  (interactive)
+  (set-buffer menudiag-selection-main-buffer)
+  (menudiag-exit-one-level))
+
+(defun menudiag-selection-exit ()
+  (interactive)
+  (set-buffer menudiag-selection-main-buffer)
+  (menudiag-exit))
 
 (provide 'menudiag)
 ;;; menudiag.el ends here.
