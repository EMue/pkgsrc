$NetBSD: patch-aa,v 1.1 2001/03/28 21:49:41 jtb Exp $

--- /dev/null	Wed Mar 28 17:30:50 2001
+++ ieee-utils/fp-netbsd.c
@@ -0,0 +1,95 @@
+#include <ieeefp.h>
+#include <sys/param.h>
+#include <gsl/gsl_ieee_utils.h>
+#include <gsl/gsl_errno.h>
+
+int
+gsl_ieee_set_mode (int precision, int rounding, int exception_mask)
+{
+  fp_except mode = 0;
+  fp_rnd    rnd  = 0;
+
+  switch (precision)
+    {
+    case GSL_IEEE_SINGLE_PRECISION:
+      GSL_ERROR ("NetBSD only supports default precision rounding",
+		 GSL_EUNSUP);
+      break;
+    case GSL_IEEE_DOUBLE_PRECISION:
+      GSL_ERROR ("NetBSD only supports default precision rounding",
+		 GSL_EUNSUP);
+      break;
+    case GSL_IEEE_EXTENDED_PRECISION:
+      GSL_ERROR ("NetBSD only supports default precision rounding",
+		 GSL_EUNSUP);
+      break;
+    }
+
+  switch (rounding)
+    {
+    case GSL_IEEE_ROUND_TO_NEAREST:
+      rnd = FP_RN;
+      fpsetround (rnd);
+      break;
+    case GSL_IEEE_ROUND_DOWN:
+      rnd = FP_RM;
+      fpsetround (rnd);
+      break;
+    case GSL_IEEE_ROUND_UP:
+      rnd = FP_RP;
+      fpsetround (rnd);
+      break;
+    case GSL_IEEE_ROUND_TO_ZERO:
+      rnd = FP_RZ;
+      fpsetround (rnd);
+      break;
+    default:
+      rnd = FP_RN;
+      fpsetround (rnd);
+    }
+
+/* Turn on all available exceptions apart from 'inexact'.
+   Denormalized operand exception not available on all ports. */
+
+#ifdef FP_X_DNML
+  mode = FP_X_INV | FP_X_DNML | FP_X_DZ | FP_X_OFL | FP_X_UFL;
+#else
+  mode = FP_X_INV | FP_X_DZ | FP_X_OFL | FP_X_UFL;
+#endif
+
+  if (exception_mask & GSL_IEEE_MASK_INVALID)
+    mode &= ~ FP_X_INV;
+
+  if (exception_mask & GSL_IEEE_MASK_DENORMALIZED)
+#ifdef FP_X_DNML
+    mode &= ~ FP_X_DNML;
+#else
+  GSL_ERROR ("netbsd-" MACHINE " does not support the denormalized operand exception. "
+	     "Use 'mask-denormalized' to work around this.",
+	     GSL_EUNSUP);
+#endif
+
+  if (exception_mask & GSL_IEEE_MASK_DIVISION_BY_ZERO)
+    mode &= ~ FP_X_DZ;
+
+  if (exception_mask & GSL_IEEE_MASK_OVERFLOW)
+    mode &= ~ FP_X_OFL;
+
+  if (exception_mask & GSL_IEEE_MASK_UNDERFLOW)
+    mode &=  ~ FP_X_UFL;
+
+  if (exception_mask & GSL_IEEE_TRAP_INEXACT)
+    {
+      mode |= FP_X_IMP;
+    }
+  else
+    {
+      mode &= ~ FP_X_IMP;
+    }
+
+  fpsetmask (mode);
+
+  return GSL_SUCCESS;
+
+}
+
