$NetBSD: patch-ac,v 1.2 2000/06/11 23:42:13 mycroft Exp $

--- bfd/elf32-mips.c.orig	Fri May  1 11:48:09 1998
+++ bfd/elf32-mips.c	Sun Jun 11 19:33:36 2000
@@ -155,6 +155,11 @@
 #define STUB_LI16 0x34180000	/* ori t8,zero,0 */
 #define MIPS_FUNCTION_STUB_SIZE (16)
 
+#if 0
+/* We no longer try to identify particular sections for the .dynsym
+   section.  When we do, we wind up crashing if there are other random
+   sections with relocations.  */
+
 /* Names of sections which appear in the .dynsym section in an Irix 5
    executable.  */
 
@@ -179,6 +184,8 @@
 
 #define MIPS_TEXT_DYNSYM_SECNO (3)
 
+#endif /* 0 */
+
 /* The names of the runtime procedure table symbols used on Irix 5.  */
 
 static const char * const mips_elf_dynsym_rtproc_names[] =
@@ -2314,7 +2321,10 @@
 	       || strcmp (name, ".dynstr") == 0))
     {
       hdr->sh_entsize = 0;
+#if 0
+      /* This isn't how the Irix 6 linker behaves.  */
       hdr->sh_info = SIZEOF_MIPS_DYNSYM_SECNAMES;
+#endif
     }
   else if (strcmp (name, ".got") == 0
 	   || strcmp (name, ".sdata") == 0
@@ -2884,8 +2894,11 @@
   bfd_h_put_16 (abfd, in->pcreg, (bfd_byte *) ex->p_pcreg);
 
   bfd_h_put_32 (abfd, in->irpss, (bfd_byte *) ex->p_irpss);
+  bfd_h_put_32 (abfd, 0, (bfd_byte *) ex->p_reserved);
 #if 0 /* FIXME */
   ecoff_put_off (abfd, in->exception_info, (bfd_byte *) ex->p_exception_info);
+#else
+  bfd_h_put_32 (abfd, 0, (bfd_byte *) ex->p_exception_info);
 #endif
 }
 
@@ -3178,8 +3191,11 @@
 struct mips_elf_link_hash_table
 {
   struct elf_link_hash_table root;
+#if 0
+  /* We no longer use this.  */
   /* String section indices for the dynamic section symbols.  */
   bfd_size_type dynsym_sec_strindex[SIZEOF_MIPS_DYNSYM_SECNAMES];
+#endif
   /* The number of .rtproc entries.  */
   bfd_size_type procedure_count;
   /* The size of the .compact_rel section (if SGI_COMPAT).  */
@@ -3264,7 +3280,6 @@
      bfd *abfd;
 {
   struct mips_elf_link_hash_table *ret;
-  unsigned int i;
 
   ret = ((struct mips_elf_link_hash_table *)
 	 bfd_alloc (abfd, sizeof (struct mips_elf_link_hash_table)));
@@ -3278,8 +3293,11 @@
       return NULL;
     }
 
+#if 0
+  /* We no longer use this.  */
   for (i = 0; i < SIZEOF_MIPS_DYNSYM_SECNAMES; i++)
     ret->dynsym_sec_strindex[i] = (bfd_size_type) -1;
+#endif
   ret->procedure_count = 0;
   ret->compact_rel_size = 0;
   ret->use_rld_obj_head = false;
@@ -6570,15 +6588,20 @@
      That means we must increment the dynamic symbol index of every
      other dynamic symbol.  */
   {
-    const char * const *namep;
     unsigned int c, i;
-    bfd_size_type strindex;
-    struct bfd_strtab_hash *dynstr;
     struct mips_got_info *g;
 
     c = 0;
     if (elf_hash_table (info)->dynamic_sections_created)
       {
+#if 0
+	/* We no longer try to restrict the set of sections which get
+           dynamic symbol table entries, since it fails if we have
+           other random sections which need dynamic relocations.  */
+	const char * const *namep;
+	bfd_size_type strindex;
+	struct bfd_strtab_hash *dynstr;
+
 	if (SGI_COMPAT (output_bfd))
 	  {
 	    c = SIZEOF_MIPS_DYNSYM_SECNAMES - 1;
@@ -6606,6 +6629,7 @@
 	      }
 	  }
 	else
+#endif /* 0 */
 	  {
 	    c = bfd_count_sections (output_bfd);
 	    elf_link_hash_traverse (elf_hash_table (info),
@@ -6962,8 +6986,11 @@
 	      break;
 
 	    case DT_MIPS_UNREFEXTNO:
-	      /* XXX FIXME: */
+#if 0
 	      dyn.d_un.d_val = SIZEOF_MIPS_DYNSYM_SECNAMES;
+#else
+	      dyn.d_un.d_val = bfd_count_sections (output_bfd);
+#endif
 	      bfd_elf32_swap_dyn_out (output_bfd, &dyn, dyncon);
 	      break;
 
@@ -7001,12 +7028,7 @@
   {
     asection *sdynsym;
     asection *s;
-    unsigned int i;
-    bfd_vma last;
     Elf_Internal_Sym sym;
-    long dindx;
-    const char *name;
-    const char * const * namep = mips_elf_dynsym_sec_names;
     Elf32_compact_rel cpt;
 
     /* Set up the section symbols for the output sections. SGI sets
@@ -7015,6 +7037,16 @@
     sdynsym = bfd_get_section_by_name (dynobj, ".dynsym");
     if (sdynsym != NULL)
       {
+#if 0
+	const char *name;
+	const char * const * namep = mips_elf_dynsym_sec_names;
+	unsigned int i;
+	bfd_vma last;
+	long dindx;
+
+	/* We no longer try to restrict the set of sections which get
+           dynamic symbol table entries, since it fails if we have
+           other random sections which need dynamic relocations.  */
 	if (SGI_COMPAT (output_bfd))
 	  {
 	    sym.st_size = 0;
@@ -7059,6 +7091,7 @@
 	      SIZEOF_MIPS_DYNSYM_SECNAMES;
 	  }
 	else
+#endif /* 0 */
 	  {
 	    sym.st_size = 0;
 	    sym.st_name = 0;
