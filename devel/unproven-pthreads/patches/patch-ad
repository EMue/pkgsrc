$NetBSD: patch-ad,v 1.1 2000/12/28 03:56:53 wiz Exp $

--- machdep/engine-alpha-netbsd-1.3.h.orig	Fri Nov 12 16:02:40 1999
+++ machdep/engine-alpha-netbsd-1.3.h
@@ -10,7 +10,15 @@
 #include <setjmp.h>
 #include <sys/time.h>
 #include <sys/cdefs.h>
-#include <sys/signal.h>	/* for _NSIG */
+#include <sys/signal.h>  /* for _NSIG */
+#include <sys/syscall.h>
+
+#include <unistd.h>
+#include <setjmp.h>
+#include <stdlib.h>
+#include <fcntl.h>
+
+#include <pthread/sysfunc.h>
 
 /* The first machine dependent functions are the SEMAPHORES needing
    the test and set instruction.
@@ -21,20 +29,20 @@
 #define SEMAPHORE_SET   1
 
 #if 0
-#define SEMAPHORE_TEST_AND_SET(lock)    			\
-({ int *_sem_lock = (lock), locked, old;			\
-   asm ("mb" : : : "memory");					\
-   do { asm ("ldl_l %0,%1" : "=r" (old) : "m" (*_sem_lock));	\
-	/* ?? if (old != SEMAPHORE_CLEAR) break; */		\
-	asm ("stl_c %0,%1" : "=r" (locked), "=m" (*_sem_lock)	\
-			   : "0" (SEMAPHORE_SET));		\
-   } while (!locked);						\
-   asm ("mb" : : : "memory");					\
+#define SEMAPHORE_TEST_AND_SET(lock)                           \
+({ int *_sem_lock = (lock), locked, old;                       \
+   asm ("mb" : : : "memory");                                      \
+   do { asm ("ldl_l %0,%1" : "=r" (old) : "m" (*_sem_lock));     \
+       /* ?? if (old != SEMAPHORE_CLEAR) break; */             \
+       asm ("stl_c %0,%1" : "=r" (locked), "=m" (*_sem_lock)     \
+                          : "0" (SEMAPHORE_SET));            \
+   } while (!locked);                                          \
+   asm ("mb" : : : "memory");                                      \
    old == SEMAPHORE_CLEAR; })
 
 #define SEMAPHORE_RESET(lock)           \
-({ int *_sem_lock = (lock);		\
-   *_sem_lock = SEMAPHORE_CLEAR;	\
+({ int *_sem_lock = (lock);            \
+   *_sem_lock = SEMAPHORE_CLEAR;       \
    asm ("mb" : : : "memory"); })
 #endif
 
@@ -46,19 +54,19 @@
 /*
  * sigset_t macros
  */
-#define	SIG_ANY(sig)		(sig)
-#define	SIGMAX			(_NSIG-1)
+#define        SIG_ANY(sig)            (sig)
+#define        SIGMAX                  (_NSIG-1)
 
 /*
  * New Strutures
  */
 struct machdep_pthread {
-    void        		*(*start_routine)(void *);
-    void        		*start_argument;
-    void        		*machdep_stack;
-    struct itimerval		machdep_timer;
-    unsigned long		machdep_istate[11];
-    unsigned long     		machdep_fstate[9];
+    void                       *(*start_routine)(void *);
+    void                       *start_argument;
+    void                       *machdep_stack;
+    struct itimerval           machdep_timer;
+    unsigned long              machdep_istate[11];
+    unsigned long              machdep_fstate[9];
 };
 
 /*
@@ -66,18 +74,18 @@
  * For initial thread only.
  */
 #define MACHDEP_PTHREAD_INIT    \
-	{ NULL, NULL, NULL, { { 0, 0 }, { 0, 100000 } }, 0 }
+       { NULL, NULL, NULL, { { 0, 0 }, { 0, 100000 } }, { 0 }, { 0 } }
 
 /*
  * Minimum stack size
  */
-#define PTHREAD_STACK_MIN	2048
+#define PTHREAD_STACK_MIN      2048
 
 /*
  * Some fd flag defines that are necessary to distinguish between posix
  * behavior and bsd4.3 behavior.
  */
-#define __FD_NONBLOCK 		O_NONBLOCK
+#define __FD_NONBLOCK          O_NONBLOCK
 
 /*
  * New functions
@@ -91,21 +99,112 @@
 #define __machdep_stack_set(x, y)   (x)->machdep_stack = y
 #define __machdep_stack_repl(x, y)                          \
 {                                                           \
-    if (stack = __machdep_stack_get(x)) {                   \
+    if ((stack = __machdep_stack_get(x))) {                 \
         __machdep_stack_free(stack);                        \
     }                                                       \
     __machdep_stack_set(x, y);                              \
 }
 
-void *  __machdep_stack_alloc(size_t);
-void    __machdep_stack_free(void *);
-
 int machdep_save_state(void);
+int safe_store (int *loc, int nw);
 
 int __machdep_save_int_state(unsigned long *);
 void __machdep_restore_int_state(unsigned long *);
 void __machdep_save_fp_state(unsigned long *);
 void __machdep_restore_fp_state(unsigned long *);
+
+void *machdep_pthread_cleanup(struct machdep_pthread *machdep_pthread);
+void machdep_pthread_start(void);
+
+/* ==========================================================================
+ * __machdep_stack_free()
+ */
+inline static
+void __machdep_stack_free(void * stack)
+{
+    free(stack);
+}
+
+/* ==========================================================================
+ * __machdep_stack_alloc()
+ */
+inline static
+void * __machdep_stack_alloc(size_t size)
+{
+    return(malloc(size));
+}
+
+/* ==========================================================================
+ * machdep_sys_creat()
+ */
+static inline int
+machdep_sys_creat(char * path, int mode)
+{  
+        return(machdep_sys_open(path, O_WRONLY | O_CREAT | O_TRUNC, mode));
+}  
+
+/* ==========================================================================
+ * machdep_sys_wait3()
+ */ 
+static inline int
+machdep_sys_wait3(int * b, int c, struct rusage *d)
+{   
+        return(machdep_sys_wait4(0, b, c, d));
+}  
+
+/* ==========================================================================
+ * machdep_sys_waitpid()
+ */  
+static inline int
+machdep_sys_waitpid(int a, int * b, int c)
+{
+        return(machdep_sys_wait4(a, b, c, NULL));
+}
+
+/* ==========================================================================
+ * machdep_sys_getdtablesize()
+ */
+static inline int
+machdep_sys_getdtablesize(void)
+{
+        return(sysconf(_SC_OPEN_MAX));
+}
+
+/* ==========================================================================
+ * machdep_sys_lseek()
+ */
+static inline
+off_t machdep_sys_lseek(int fd, off_t offset, int whence)
+{
+       return(__syscall((quad_t)SYS_lseek, fd, 0, offset, whence));
+}
+
+static inline
+int machdep_sys_ftruncate( int fd, off_t length)
+{
+       quad_t q;
+       int rv;
+
+       q = __syscall((quad_t)SYS_ftruncate, fd,0, length);
+       if( /* LINTED constant */ sizeof( quad_t ) == sizeof( register_t ) ||
+           /* LINTED constant */ BYTE_ORDER == LITTLE_ENDIAN )
+               rv = (int)q;
+       else
+               rv = (int)((u_quad_t)q >> 32);
+
+       return rv;
+}
+
+
+/* ==========================================================================
+ * machdep_sys_getdirentries()
+ */
+static inline int
+machdep_sys_getdirentries(int fd, char * buf, int len, int * seek)
+{
+        return(machdep_sys_getdents(fd, buf, len));
+} 
+
 
 #endif
 
