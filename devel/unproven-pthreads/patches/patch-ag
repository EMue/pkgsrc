$NetBSD: patch-ag,v 1.1 2000/12/28 03:56:54 wiz Exp $

--- machdep/engine-alpha-netbsd-1.3.c.orig	Fri Dec 10 13:40:41 1999
+++ machdep/engine-alpha-netbsd-1.3.c
@@ -3,17 +3,17 @@
  *
  * Description : Machine dependent functions for NetBSD/Alpha 1.1(+)
  *
- *	1.00 93/08/04 proven
+ *     1.00 93/08/04 proven
  *      -Started coding this file.
  *
- *	95/04/22 cgd
- *	-Modified to make it go with NetBSD/Alpha
+ *     95/04/22 cgd
+ *     -Modified to make it go with NetBSD/Alpha
  */
 
 #ifndef lint
 static const char rcsid[] = "engine-alpha-osf1.c,v 1.4.4.1 1995/12/13 05:41:37 proven Exp";
 #endif
- 
+
 #include <pthread.h>
 #include <sys/types.h>
 #include <sys/socket.h>
@@ -23,77 +23,24 @@
 #include <stdio.h>
 
 /* ==========================================================================
- * machdep_save_state()
- */
-int machdep_save_state(void)
-{
-  return __machdep_save_int_state(pthread_run->machdep_data.machdep_istate);
-}
-
-void machdep_restore_state(void)
-{
-  __machdep_restore_int_state(pthread_run->machdep_data.machdep_istate);
-}
-
-void machdep_save_float_state (void)
-{
-  __machdep_save_fp_state(pthread_run->machdep_data.machdep_fstate);
-}
-
-void machdep_restore_float_state (void)
-{
-  __machdep_restore_fp_state(pthread_run->machdep_data.machdep_fstate);
-}
-
-/* ==========================================================================
- * machdep_set_thread_timer()
- */
-void machdep_set_thread_timer(struct machdep_pthread *machdep_pthread)
-{
-    if (setitimer(ITIMER_VIRTUAL, &(machdep_pthread->machdep_timer), NULL)) {
-        PANIC("setitimer failed");
-    }
-}
-
-/* ==========================================================================
- * machdep_unset_thread_timer()
- */
-void machdep_unset_thread_timer(struct machdep_pthread *machdep_pthread)
-{
-    struct itimerval zeroval = { { 0, 0 }, { 0, 0} };
-
-    if (setitimer(ITIMER_VIRTUAL, &zeroval, NULL)) {
-        PANIC("setitimer failed");
-    }
-}
-
-/* ==========================================================================
- * machdep_pthread_cleanup()
- */
-void *machdep_pthread_cleanup(struct machdep_pthread *machdep_pthread)
-{
-    return(machdep_pthread->machdep_stack);
-}
-
-/* ==========================================================================
  * machdep_pthread_start()
  */
 void machdep_pthread_start(void)
 {
-	context_switch_done();
-	pthread_sched_resume ();
+       context_switch_done();
+       pthread_sched_resume ();
 
-	/* XXXMLG
-	 * This is EXTREMELY bogus, but it seems that this function is called
-	 * with the pthread kernel locked.  If this happens, __errno() will
-	 * return the wrong address until after the first context switch.
-	 *
-	 * Clearly there is a leak of pthread_kernel somewhere, but until
-	 * it is found, we force a context switch here, just before calling
-	 * the thread start routine.  When we return from pthread_yield
-	 * the kernel will be unlocked.
-	 */
-	pthread_yield();
+       /* XXXMLG
+        * This is EXTREMELY bogus, but it seems that this function is called
+        * with the pthread kernel locked.  If this happens, __errno() will
+        * return the wrong address until after the first context switch.
+        *
+        * Clearly there is a leak of pthread_kernel somewhere, but until
+        * it is found, we force a context switch here, just before calling
+        * the thread start routine.  When we return from pthread_yield
+        * the kernel will be unlocked.
+        */
+       pthread_yield();
 
     /* Run current threads start routine with argument */
     pthread_exit(pthread_run->machdep_data.start_routine
@@ -104,28 +51,10 @@
 }
 
 /* ==========================================================================
- * __machdep_stack_free()
- */
-void __machdep_stack_free(void * stack)
-{
-    free(stack);
-}
-
-/* ==========================================================================
- * __machdep_stack_alloc()
- */
-void * __machdep_stack_alloc(size_t size)
-{
-    void * stack;
-
-    return(malloc(size));
-}
-
-/* ==========================================================================
  * __machdep_pthread_create()
  */
 void __machdep_pthread_create(struct machdep_pthread *machdep_pthread,
-  void *(* start_routine)(), void *start_argument, 
+  void *(* start_routine)(void *), void *start_argument,
   long stack_size, long nsec, long flags)
 {
     machdep_pthread->start_routine = start_routine;
@@ -151,66 +80,68 @@
     }
 }
 
-int safe_store (loc, new)
-     int *loc;
-     int new;
+/* ==========================================================================
+ * machdep_save_state()
+ */
+int machdep_save_state(void)
 {
-  int locked, old;
-  asm ("mb" : : : "memory");
-  do {
-    asm ("ldl_l %0,%1" : "=r" (old) : "m" (*loc));
-    asm ("stl_c %0,%1" : "=r" (locked), "=m" (*loc) : "0" (new));
-  } while (!locked);
-  asm ("mb" : : : "memory");
-  return old;
+  return __machdep_save_int_state(pthread_run->machdep_data.machdep_istate);
 }
 
-/* ==========================================================================
- * machdep_sys_creat()
- */
-machdep_sys_creat(char * path, int mode)
-{   
-        return(machdep_sys_open(path, O_WRONLY | O_CREAT | O_TRUNC, mode));
-}   
+void machdep_restore_state(void)
+{
+  __machdep_restore_int_state(pthread_run->machdep_data.machdep_istate);
+}
 
-/* ==========================================================================
- * machdep_sys_wait3()
- */  
-machdep_sys_wait3(int * b, int c, int * d)
-{    
-        return(machdep_sys_wait4(0, b, c, d));
-}   
- 
-/* ==========================================================================
- * machdep_sys_waitpid()
- */   
-machdep_sys_waitpid(int a, int * b, int c)
+void machdep_save_float_state (struct pthread *pthread)
+{
+  __machdep_save_fp_state(pthread->machdep_data.machdep_fstate);
+}
+
+void machdep_restore_float_state (void)
 {
-        return(machdep_sys_wait4(a, b, c, NULL));
+  __machdep_restore_fp_state(pthread_run->machdep_data.machdep_fstate);
 }
 
 /* ==========================================================================
- * machdep_sys_getdtablesize()
+ * machdep_set_thread_timer()
  */
-machdep_sys_getdtablesize()
+void machdep_set_thread_timer(struct machdep_pthread *machdep_pthread)
 {
-        return(sysconf(_SC_OPEN_MAX));
+    if (setitimer(ITIMER_VIRTUAL, &(machdep_pthread->machdep_timer), NULL)) {
+        PANIC("setitimer failed");
+    }
 }
 
 /* ==========================================================================
- * machdep_sys_lseek()
+ * machdep_unset_thread_timer()
  */
-off_t machdep_sys_lseek(int fd, off_t offset, int whence)
+void machdep_unset_thread_timer(struct machdep_pthread *machdep_pthread)
 {
-	extern off_t __syscall();
+    struct itimerval zeroval = { { 0, 0 }, { 0, 0} };
 
-	return(__syscall((quad_t)SYS_lseek, fd, 0, offset, whence));
+    if (setitimer(ITIMER_VIRTUAL, &zeroval, NULL)) {
+        PANIC("setitimer failed");
+    }
 }
 
 /* ==========================================================================
- * machdep_sys_getdirentries()
+ * machdep_pthread_cleanup()
  */
-machdep_sys_getdirentries(int fd, char * buf, int len, int * seek)
+void *machdep_pthread_cleanup(struct machdep_pthread *machdep_pthread)
 {
-        return(machdep_sys_getdents(fd, buf, len));
-}  
+    return(machdep_pthread->machdep_stack);
+}
+
+int safe_store (int *loc, int new)
+{
+  int locked, old;
+  asm ("mb" : : : "memory");
+  do {
+    asm ("ldl_l %0,%1" : "=r" (old) : "m" (*loc));
+    asm ("stl_c %0,%1" : "=r" (locked), "=m" (*loc) : "0" (new));
+  } while (!locked);
+  asm ("mb" : : : "memory");
+  return old;
+}
+
