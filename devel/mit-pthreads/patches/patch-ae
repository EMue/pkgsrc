$NetBSD: patch-ae,v 1.1 1998/08/23 06:22:17 garbled Exp $
--- /dev/null	Sat Jul 18 04:39:35 1998
+++ machdep/syscall-template-alpha-netbsd-1.3.S	Sat Jul 18 04:41:03 1998
@@ -0,0 +1,46 @@
+#include <machine/asm.h>
+#define COMPAT_43
+#include <sys/syscall.h>
+#define CHMK()		call_pal 0x83
+
+#undef SYSCALL
+
+/* Kernel syscall interface:
+   Input:
+	v0 - system call number
+	a* - arguments, as in C
+   Output:
+	a3 - zero iff successful
+	v0 - errno value on failure, else result
+
+   This macro is similar to SYSCALL in asm.h, but not completely.
+   There's room for optimization, if we assume this will continue to
+   be assembled as one file.
+
+   This macro expansions does not include the return instruction.
+   If there's no other work to be done, use something like:
+	SYSCALL(foo) ; ret
+   If there is other work to do (in fork, maybe?), do it after the
+   SYSCALL invocation.  */
+
+#define SYSCALL(x) \
+	.align	4					;\
+	.globl	machdep_sys_##x				;\
+	.ent	machdep_sys_##x, 0			;\
+machdep_sys_##x:					;\
+	.frame	sp,0,ra					;\
+	ldiq	v0, SYS_##x				;\
+	CHMK()						;\
+	beq	a3, Lsys_noerr_##x			;\
+	br	gp, Lsys_err_##x			;\
+Lsys_err_##x:						;\
+	/* Load gp so we can find cerror to jump to.  */;\
+	ldgp	gp, 0(gp)				;\
+	jmp	zero, machdep_cerror			;\
+Lsys_noerr_##x:
+
+#define SIMPLE_SYSCALL(x)	SYSCALL(x) ; ret ; .end machdep_sys_##x
+
+#define XSYSCALL(x)	SIMPLE_SYSCALL(x)
+
+XSYSCALL(SYSCALL_NAME)
