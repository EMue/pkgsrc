$NetBSD: patch-ao,v 1.1 2000/08/22 15:08:45 wennmach Exp $

Deal with a potential deadlock situation, which may arise when writing back
data from a vnode failed because the ticket expired in the meantime.
From arla-current, thanks to Assar and Love.

Index: xfs_vnodeops-common.c
===================================================================
RCS file: /afs/stacken.kth.se/src/SourceRepository/arla/xfs/bsd/xfs_vnodeops-common.c,v
retrieving revision 1.58
diff -u -w -u -w -r1.58 xfs_vnodeops-common.c
--- xfs/bsd/xfs_vnodeops-common.c	2000/08/02 00:58:09	1.58
+++ xfs/bsd/xfs_vnodeops-common.c	2000/08/17 00:30:23
@@ -260,8 +260,17 @@
 	return 0;
     }
     
-    if (xn->flags & XFS_DATA_DIRTY)
+    if (xn->flags & XFS_DATA_DIRTY) {
+#ifdef FSYNC_RECLAIM
+	/* writing back the data from this vnode failed */
+	if (waitfor & FSYNC_RECLAIM) {
+	    printf("xfs_fsync: data lost, failed to write back\n");
+	    xn->flags &= ~XFS_DATA_DIRTY;
+	    return 0;
+	}
+#endif    
 	error = do_fsync(xfsp, xn, cred, proc, XFS_WRITE | XFS_FSYNC);
+    }
 
     return error;
 }
@@ -907,8 +916,9 @@
     /* xn->cred not set -> NOCRED */
 
     error = xfs_fsync_common(vp, xn->cred, /* XXX */ 0, p);
-    if (error)
-	XFSDEB(XDEBVNOPS, ("xfs_inactive: fsync failed: %d\n", error));
+    if (error) {
+	printf ("xfs_inactive: failed writing back data: %d\n", error);
+    }
 
 #ifndef __osf__
     xfs_vfs_unlock(vp, p);
