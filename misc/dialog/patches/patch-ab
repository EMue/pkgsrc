$NetBSD: patch-ab,v 1.3 2000/07/28 20:30:11 jlam Exp $

--- checklist.c.orig	Thu Aug 17 19:36:06 1995
+++ checklist.c	Fri Jul 28 15:30:22 2000
@@ -64,8 +64,8 @@
 	int list_height, int item_no, const char * const * items, int flag,
 	int separate_output)
 {
-    int i, x, y, cur_x, cur_y, box_x, box_y;
-    int key = 0, button = 0, choice = 0, scroll = 0, max_choice, *status;
+    int i, j, x, y, cur_x, cur_y, box_x, box_y;
+    int key = 0, button = 0, choice = 0, d_scroll = 0, max_choice, *status;
     WINDOW *dialog, *list;
 
     checkflag = flag;
@@ -83,6 +83,26 @@
 
     max_choice = MIN (list_height, item_no);
 
+    /* Find length of longest item in order to center checklist */
+    check_x = 0;
+    item_x = 0;
+    for (i = 0; i < item_no; i++) {
+        check_x = MAX (check_x, strlen (items[i * 3])
+                       + strlen (items[i * 3 + 1]) + 6);
+        item_x = MAX (item_x, strlen (items[i * 3]));
+    }
+
+    /* Choose useful default height and width if they are negative */
+    if (height < 0)
+        height = strheight(prompt) + list_height + 4 + 2;
+    if (width < 0) {
+        i = strwidth(prompt);
+        j = ((title != NULL) ? strwidth(title) : 0);
+        width = MAX (i, j);
+        width = MAX (width, check_x + 4) + 4;
+    }
+    width = MAX (width, MIN_DIALOG_WIDTH);
+
     /* center dialog box on screen */
     x = (COLS - width) / 2;
     y = (LINES - height) / 2;
@@ -131,14 +151,6 @@
     draw_box (dialog, box_y, box_x, list_height + 2, list_width + 2,
 	      menubox_border_attr, menubox_attr);
 
-    check_x = 0;
-    item_x = 0;
-    /* Find length of longest item in order to center checklist */
-    for (i = 0; i < item_no; i++) {
-	check_x = MAX (check_x, strlen (items[i * 3])
-		       + strlen (items[i * 3 + 1]) + 6);
-	item_x = MAX (item_x, strlen (items[i * 3]));
-    }
     check_x = (list_width - check_x) / 2;
     item_x = check_x + item_x + 6;
 
@@ -171,7 +183,7 @@
 	   any item tag in list */
 	for (i = 0; i < max_choice; i++)
 	    if (toupper (key) ==
-		toupper (items[(scroll + i) * 3][0]))
+		toupper (items[(d_scroll + i) * 3][0]))
 		break;
 
 	if (i < max_choice ||
@@ -183,35 +195,35 @@
 		i = key - '1';
 	    else if (key == KEY_UP || key == '-') {
 		if (!choice) {
-		    if (!scroll)
+		    if (!d_scroll)
 			continue;
 		    /* Scroll list down */
 		    getyx (dialog, cur_y, cur_x);
 		    if (list_height > 1) {
 			/* De-highlight current first item */
-			print_item (list, items[scroll * 3],
-				    items[scroll * 3 + 1], status[scroll],
+			print_item (list, items[d_scroll * 3],
+				    items[d_scroll * 3 + 1], status[d_scroll],
 				    0, FALSE);
 			scrollok (list, TRUE);
 			wscrl (list, -1);
 			scrollok (list, FALSE);
 		    }
-		    scroll--;
-		    print_item (list, items[scroll * 3],
-				items[scroll * 3 + 1],
-				status[scroll], 0, TRUE);
+		    d_scroll--;
+		    print_item (list, items[d_scroll * 3],
+				items[d_scroll * 3 + 1],
+				status[d_scroll], 0, TRUE);
 		    wnoutrefresh (list);
 
 		    /* print the up/down arrows */
 		    wmove (dialog, box_y, box_x + check_x + 5);
-		    wattrset (dialog, scroll ? uarrow_attr : menubox_attr);
-		    waddch (dialog, scroll ? ACS_UARROW : ACS_HLINE);
+		    wattrset (dialog, d_scroll ? uarrow_attr : menubox_attr);
+		    waddch (dialog, d_scroll ? ACS_UARROW : ACS_HLINE);
 		    wmove (dialog, box_y, box_x + check_x + 6);
-		    waddch (dialog, scroll ? '(' : ACS_HLINE);
+		    waddch (dialog, d_scroll ? '(' : ACS_HLINE);
 		    wmove (dialog, box_y, box_x + check_x + 7);
-		    waddch (dialog, scroll ? '-' : ACS_HLINE);
+		    waddch (dialog, d_scroll ? '-' : ACS_HLINE);
 		    wmove (dialog, box_y, box_x + check_x + 8);
-		    waddch (dialog, scroll ? ')' : ACS_HLINE);
+		    waddch (dialog, d_scroll ? ')' : ACS_HLINE);
 		    wattrset (dialog, darrow_attr);
 		    wmove (dialog, box_y + list_height + 1,
 			   box_x + check_x + 5);
@@ -232,24 +244,24 @@
 		    i = choice - 1;
 	    } else if (key == KEY_DOWN || key == '+') {
 		if (choice == max_choice - 1) {
-		    if (scroll + choice >= item_no - 1)
+		    if (d_scroll + choice >= item_no - 1)
 			continue;
 		    /* Scroll list up */
 		    getyx (dialog, cur_y, cur_x);
 		    if (list_height > 1) {
 			/* De-highlight current last item before scrolling up */
-			print_item (list, items[(scroll + max_choice - 1) * 3],
-				    items[(scroll + max_choice - 1) * 3 + 1],
-				    status[scroll + max_choice - 1],
+			print_item (list, items[(d_scroll + max_choice - 1) * 3],
+				    items[(d_scroll + max_choice - 1) * 3 + 1],
+				    status[d_scroll + max_choice - 1],
 				    max_choice - 1, FALSE);
 			scrollok (list, TRUE);
 			scroll (list);
 			scrollok (list, FALSE);
 		    }
-		    scroll++;
-		    print_item (list, items[(scroll + max_choice - 1) * 3],
-				items[(scroll + max_choice - 1) * 3 + 1],
-				status[scroll + max_choice - 1],
+		    d_scroll++;
+		    print_item (list, items[(d_scroll + max_choice - 1) * 3],
+				items[(d_scroll + max_choice - 1) * 3 + 1],
+				status[d_scroll + max_choice - 1],
 				max_choice - 1, TRUE);
 		    wnoutrefresh (list);
 
@@ -261,21 +273,21 @@
 		    waddstr (dialog, "(-)");
 		    wmove (dialog, box_y + list_height + 1,
 			   box_x + check_x + 5);
-		    wattrset (dialog, scroll + choice < item_no - 1 ?
+		    wattrset (dialog, d_scroll + choice < item_no - 1 ?
 			      darrow_attr : menubox_border_attr);
-		    waddch (dialog, scroll + choice < item_no - 1 ?
+		    waddch (dialog, d_scroll + choice < item_no - 1 ?
 			    ACS_DARROW : ACS_HLINE);
 		    wmove (dialog, box_y + list_height + 1,
 			   box_x + check_x + 6);
-		    waddch (dialog, scroll + choice < item_no - 1 ?
+		    waddch (dialog, d_scroll + choice < item_no - 1 ?
 			    '(' : ACS_HLINE);
 		    wmove (dialog, box_y + list_height + 1,
 			   box_x + check_x + 7);
-		    waddch (dialog, scroll + choice < item_no - 1 ?
+		    waddch (dialog, d_scroll + choice < item_no - 1 ?
 			    '+' : ACS_HLINE);
 		    wmove (dialog, box_y + list_height + 1,
 			   box_x + check_x + 8);
-		    waddch (dialog, scroll + choice < item_no - 1 ?
+		    waddch (dialog, d_scroll + choice < item_no - 1 ?
 			    ')' : ACS_HLINE);
 		    wmove (dialog, cur_y, cur_x);
 		    wrefresh (dialog);
@@ -284,21 +296,21 @@
 		    i = choice + 1;
 	    } else if (key == ' ') {	/* Toggle item status */
 		if (flag == FLAG_CHECK) {
-		    status[scroll + choice] = !status[scroll + choice];
+		    status[d_scroll + choice] = !status[d_scroll + choice];
 		    getyx (dialog, cur_y, cur_x);
 		    wmove (list, choice, check_x);
 		    wattrset (list, check_selected_attr);
-		    wprintw (list, "[%c]", status[scroll + choice] ? 'X' : ' ');
+		    wprintw (list, "[%c]", status[d_scroll + choice] ? 'X' : ' ');
 		} else {
-		    if (!status[scroll + choice]) {
+		    if (!status[d_scroll + choice]) {
 			for (i = 0; i < item_no; i++)
 			    status[i] = 0;
-			status[scroll + choice] = 1;
+			status[d_scroll + choice] = 1;
 			getyx (dialog, cur_y, cur_x);
 			for (i = 0; i < max_choice; i++)
-			    print_item (list, items[(scroll + i) * 3],
-					items[(scroll + i) * 3 + 1],
-					status[scroll + i], i, i == choice);
+			    print_item (list, items[(d_scroll + i) * 3],
+					items[(d_scroll + i) * 3 + 1],
+					status[d_scroll + i], i, i == choice);
 		    }
 		}
 		wnoutrefresh (list);
@@ -309,14 +321,14 @@
 	    if (i != choice) {
 		/* De-highlight current item */
 		getyx (dialog, cur_y, cur_x);
-		print_item (list, items[(scroll + choice) * 3],
-			    items[(scroll + choice) * 3 + 1],
-			    status[scroll + choice], choice, FALSE);
+		print_item (list, items[(d_scroll + choice) * 3],
+			    items[(d_scroll + choice) * 3 + 1],
+			    status[d_scroll + choice], choice, FALSE);
 		/* Highlight new item */
 		choice = i;
-		print_item (list, items[(scroll + choice) * 3],
-			    items[(scroll + choice) * 3 + 1],
-			    status[scroll + choice], choice, TRUE);
+		print_item (list, items[(d_scroll + choice) * 3],
+			    items[(d_scroll + choice) * 3 + 1],
+			    status[d_scroll + choice], choice, TRUE);
 		wnoutrefresh (list);
 		wmove (dialog, cur_y, cur_x);
 		wrefresh (dialog);
